#!/bin/bash
# ============================
# vscreen - Virtual Display Manager
# Version: 2.1.0
# ============================

set -o pipefail

# ============================
# Configuration
# ============================
DRY_RUN=false
DEBUG=false
AUTO_POS=true
ORIENTATION="normal"

MANUAL_SIZE=false
MANUAL_W=""
MANUAL_H=""
MANUAL_POS=""

VERSION="2.1.0"

# ============================
# Available Resolutions
# ============================
RESOLUTIONS=(
  "1 FHD   1920 1080 16:9  Desktop"
  "2 HD+   1600 900  16:9  Tablet-large-UI"
  "3 HD    1366 768  16:9  Tablet-comfortable"
  "4 HD10  1280 800  16:10 Tablet-16:10"
  "5 HD+10 1440 900  16:10 Tablet-large-16:10"
  "6 SD    800  450  16:9  Phone"
)

# ============================
# Colors
# ============================
if [[ -t 1 ]]; then
  RED='\033[0;31m'
  GREEN='\033[0;32m'
  YELLOW='\033[1;33m'
  BLUE='\033[0;34m'
  NC='\033[0m'
else
  RED='' GREEN='' YELLOW='' BLUE='' NC=''
fi

# ============================
# Cleanup Handler
# ============================
cleanup() {
  local exit_code=$?
  if [[ $exit_code -ne 0 ]]; then
    log_debug "Script interrupted or failed with code $exit_code"
  fi
  exit $exit_code
}

trap cleanup INT TERM EXIT

# ============================
# Logging Helpers
# ============================
log_debug() { $DEBUG && echo -e "${BLUE}[debug]${NC} $*" >&2; }
log_info()  { echo -e "${GREEN}[info]${NC} $*" >&2; }
log_warn()  { echo -e "${YELLOW}[warn]${NC} $*" >&2; }
log_error() { echo -e "${RED}[error]${NC} $*" >&2; }

# ============================
# Command Execution
# ============================
run() {
  if $DRY_RUN; then
    echo -e "${YELLOW}[dry-run]${NC} $*"
    return 0
  fi
  log_debug "Executing: $*"
  eval "$@"
  local ret=$?
  [[ $ret -ne 0 ]] && log_error "Command failed (exit code $ret): $*"
  return $ret
}

# ============================
# Dependency Check
# ============================
check_dependencies() {
  local missing=()
  command -v xrandr &>/dev/null || missing+=("xrandr")
  command -v cvt &>/dev/null || missing+=("cvt")
  command -v awk &>/dev/null || missing+=("awk")
  
  if [[ ${#missing[@]} -gt 0 ]]; then
    log_error "Missing required dependencies: ${missing[*]}"
    echo "Install with: sudo apt install x11-xserver-utils gawk" >&2
    exit 1
  fi
}

# ============================
# Help & Version
# ============================
show_help() {
  cat << 'EOF'
vscreen - Virtual Display Manager

USAGE:
  vscreen [OPTIONS] [ACTION]

ACTIONS:
  --output <N>              Activate VIRTUAL<N> output (requires -r or --size)
  -c, --change <N>          Change existing VIRTUAL<N> configuration
  --off <N>                 Disable VIRTUAL<N> (keeps custom modes)
  --off-all                 Disable all virtual displays (keeps custom modes)
  --purge <N>               Disable VIRTUAL<N> and remove its custom modes
  --purge-all               Disable all virtual displays and remove all custom modes
  --list [all|active|free]  List virtual outputs (default: all)
  --version                 Show version information
  --help                    Show this help message

RESOLUTION OPTIONS:
  -r, --resolution <id|name>  Use predefined resolution
  --size WxH                  Use custom resolution (e.g., 1920x1080)

ORIENTATION:
  -o, --orientation <mode>
       L, normal              Landscape (default)
       PR, right              Portrait Right (90° clockwise)
       PL, left               Portrait Left (90° counter-clockwise)
       LF, inverted           Landscape Flipped (180°)

POSITIONING:
  --right-of <output>       Place display to the right of <output>
  --left-of  <output>       Place display to the left of <output>
  --above    <output>       Place display above <output>
  --below    <output>       Place display below <output>
  --pos XxY                 Set absolute position (e.g., 1920x0)

GLOBAL OPTIONS:
  --no-auto                 Disable automatic positioning
  --dry-run                 Show commands without executing
  --debug                   Enable debug output

AVAILABLE RESOLUTIONS:
EOF

  for r in "${RESOLUTIONS[@]}"; do
    IFS=' ' read -r ID NAME W H A DESC <<< "$r"
    printf "  %s: %-6s (%sx%-4s, %-5s) - %s\n" "$ID" "$NAME" "$W" "$H" "$A" "${DESC//-/ }"
  done
  
  cat << 'EOF'

EXAMPLES:
  vscreen --output 1 -r FHD
  vscreen --output 2 --size 1600x900 --right-of eDP1
  vscreen --change 1 -o right
  vscreen --purge 1
  vscreen --purge-all
  vscreen --list
EOF
}

show_version() { echo "vscreen version $VERSION"; }

# ============================
# Resolution Handling
# ============================
get_resolution() {
  local key="$1"
  for r in "${RESOLUTIONS[@]}"; do
    IFS=' ' read -r ID NAME W H A DESC <<< "$r"
    if [[ "$key" == "$ID" || "$key" == "$NAME" ]]; then
      echo "$W $H"
      return 0
    fi
  done
  log_error "Invalid resolution: $key"
  return 1
}

# ============================
# Output Discovery
# ============================
list_virtual_outputs() {
  xrandr 2>/dev/null | awk '/^VIRTUAL[0-9]+/{print $1}' | sort -V || {
    log_error "Failed to list virtual outputs"
    return 1
  }
}

list_active_virtuals() {
  xrandr 2>/dev/null | awk '/^VIRTUAL[0-9]+ connected [0-9]+/{print $1}' | sort -V || {
    log_error "Failed to list active virtuals"
    return 1
  }
}

list_free_virtuals() {
  local active
  active=$(list_active_virtuals)
  
  if [[ -z "$active" ]]; then
    list_virtual_outputs
  else
    list_virtual_outputs | grep -vFxf <(echo "$active")
  fi
}

pick_virtual_output() {
  local output
  output=$(list_free_virtuals | head -n 1)
  if [[ -z "$output" ]]; then
    log_error "No free VIRTUAL outputs available"
    return 1
  fi
  echo "$output"
}

validate_virtual_output() {
  local num="$1"
  local output="VIRTUAL${num}"
  if ! list_virtual_outputs | grep -q "^${output}$"; then
    log_error "Output $output does not exist"
    return 1
  fi
  return 0
}

is_output_active() {
  local output="$1"
  xrandr 2>/dev/null | grep -qE "^${output} connected [0-9]+"
}

is_output_connected() {
  local output="$1"
  xrandr 2>/dev/null | grep -qE "^${output} connected"
}

# ============================
# Mode Management
# ============================
mode_exists() {
  local name="$1"
  xrandr 2>/dev/null | grep -q "^\s*${name}\s"
}

create_mode_if_needed() {
  local w="$1" h="$2"
  log_debug "Creating mode for ${w}x${h}"
  
  local full params name
  full=$(cvt "$w" "$h" 60 2>&1) || {
    log_error "Failed to calculate modeline with cvt"
    return 1
  }
  
  params=$(echo "$full" | sed -n 's/.*Modeline //p')
  [[ -z "$params" ]] && { log_error "Failed to parse modeline"; return 1; }
  
  name=$(echo "$params" | awk '{print $1}' | tr -d '"')
  [[ -z "$name" ]] && { log_error "Failed to extract mode name"; return 1; }
  
  if ! mode_exists "$name"; then
    log_debug "Mode $name does not exist, creating..."
    run xrandr --newmode $params || { log_error "Failed to create mode $name"; return 1; }
  else
    log_debug "Mode $name already exists"
  fi
  
  echo "$name"
}

# ============================
# Output Purge (off + remove modes)
# ============================
purge_output() {
  local output="$1"

  log_info "Purging $output"

  # Capture output block from xrandr (output line + its modes)
  local output_block
  output_block=$(xrandr 2>/dev/null | awk '/^'"${output}"' /{found=1} found && /^[A-Z]/ && !/^'"${output}"' /{exit} found{print}')
  
  if [[ -z "$output_block" ]]; then
    log_warn "Could not find $output in xrandr"
    return 1
  fi
  
  log_debug "Output block captured:"
  log_debug "$output_block"
  
  # Disable output first
  log_debug "Disabling $output"
  if ! xrandr --output "$output" --off 2>/dev/null; then
    log_warn "Failed to disable $output (may already be off)"
  fi
  
  # Extract custom modes (format: 1920x1080_60.00)
  local modes
  modes=$(echo "$output_block" | grep -oE '[0-9]+x[0-9]+_[0-9.]+' || true)
  
  if [[ -z "$modes" ]]; then
    log_info "No modes found in $output to remove"
    return 0
  fi
  
  log_debug "Modes found: $modes"
  
  # Remove each mode
  local mode_count=0
  local fail_count=0
  for mode in $modes; do
    log_debug "Removing mode $mode from $output"
    if xrandr --delmode "$output" "$mode" 2>/dev/null; then
      ((mode_count++))
      # Try to remove mode globally (only works if no other output uses it)
      if xrandr --rmmode "$mode" 2>/dev/null; then
        log_info "Mode $mode was removed globally"
      else
        log_warn "Mode $mode cannot be removed globally"
      fi
    else
      ((fail_count++))
      log_debug "Failed to remove $mode (may not be attached)"
    fi
  done
  
  # Verify purge worked
  local remaining
  remaining=$(xrandr 2>/dev/null | awk '/^'"${output}"' /{found=1} found{print} found && /^[A-Z]/ && !/^'"${output}"' /{exit}' | grep -oE '[0-9]+x[0-9]+_[0-9.]+' || true)
  
  if [[ -n "$remaining" ]]; then
    log_warn "Some modes still attached to $output: $remaining"
    return 1
  fi
  
  log_info "Purge complete for $output ($mode_count modes removed)"
  return 0
}

purge_all_outputs() {
  local virtuals
  virtuals=$(list_virtual_outputs)
  
  if [[ -z "$virtuals" ]]; then
    log_warn "No virtual outputs found"
    return 0
  fi
  
  for v in $virtuals; do
    log_info "Purging $output"
    purge_output "$v"
  done
  
  log_info "All virtual outputs purged"
}

# ============================
# Smart Positioning
# ============================
get_smart_position() {
  local target="$1"
  local active
  active=$(xrandr --listmonitors 2>/dev/null | awk 'NR>1 {print $NF}' | grep -v "^${target}$")
  
  [[ -z "$active" ]] && return 0
  
  # If target is VIRTUAL and there are other VIRTUALs, position right of the last one
  if [[ "$target" =~ VIRTUAL ]]; then
    local prev
    prev=$(echo "$active" | grep VIRTUAL | sort | tail -n 1)
    [[ -n "$prev" ]] && { echo "--right-of $prev"; return 0; }
  fi
  
  # Try external monitor first
  local ext
  ext=$(echo "$active" | grep -E '^(HDMI|DP|VGA)' | head -n1)
  [[ -n "$ext" ]] && { echo "--right-of $ext"; return 0; }
  
  # Fall back to internal
  local int
  int=$(echo "$active" | grep -E '^(eDP|LVDS)' | head -n1)
  [[ -n "$int" ]] && { echo "--right-of $int"; return 0; }
  
  # Last resort: use first active
  local first
  first=$(echo "$active" | head -n1)
  [[ -n "$first" ]] && echo "--right-of $first"
}

# ============================
# Display Activation
# ============================
enable_virtual() {
  local output="$1" w="$2" h="$3"
  log_debug "Enabling $output (${w}x${h}, orientation: $ORIENTATION)"
  
  # Determine positioning
  local pos_arg=""
  if [[ -n "$MANUAL_POS" ]]; then
    pos_arg="$MANUAL_POS"
    log_debug "Using manual position: $pos_arg"
  elif $AUTO_POS; then
    pos_arg=$(get_smart_position "$output")
    log_debug "Using smart position: $pos_arg"
  fi
  
  # Create and apply mode if dimensions provided
  if [[ -n "$w" && -n "$h" ]]; then
    local mode
    mode=$(create_mode_if_needed "$w" "$h") || return 1
    
    log_debug "Adding mode $mode to $output"
    run xrandr --addmode "$output" "$mode" || {
      log_error "Failed to add mode $mode to $output"
      return 1
    }
    
    sleep 0.1
    
    log_info "Activating $output with mode $mode"
    run xrandr --output "$output" --mode "$mode" --rotate "$ORIENTATION" $pos_arg || {
      log_error "Failed to activate $output"
      return 1
    }
  else
    log_info "Updating $output configuration"
    run xrandr --output "$output" --rotate "$ORIENTATION" $pos_arg || {
      log_error "Failed to update $output"
      return 1
    }
  fi
  
  log_info "Successfully configured $output"
}

# ============================
# Action Handlers
# ============================
action_list() {
  case "$LIST_MODE" in
    all)    list_virtual_outputs ;;
    active) list_active_virtuals ;;
    free)   list_free_virtuals ;;
    *)
      log_error "Invalid list mode: $LIST_MODE"
      echo "Valid modes: all, active, free" >&2
      return 1
      ;;
  esac
}

action_off() {
  local output="VIRTUAL${TARGET}"
  validate_virtual_output "$TARGET" || return 1
  
  if ! is_output_active "$output"; then
    log_warn "$output is not active"
    return 0
  fi
  
  log_info "Disabling $output"
  run xrandr --output "$output" --off || return 1
  log_info "$output disabled successfully"
}

action_off_all() {
  local active
  active=$(list_active_virtuals)
  
  if [[ -z "$active" ]]; then
    log_info "No active virtual displays to disable"
    return 0
  fi
  
  for v in $active; do
    log_info "Disabling $v"
    run xrandr --output "$v" --off || log_warn "Failed to disable $v"
  done
  
  log_info "All virtual displays disabled"
}

action_purge() {
  local output="VIRTUAL${TARGET}"
  validate_virtual_output "$TARGET" || return 1
  
  log_info "Purging $output"
  purge_output "$output"
  log_info "$output purged successfully"
}

action_purge_all() {
  purge_all_outputs
}

action_output() {
  local output="VIRTUAL${TARGET}"
  validate_virtual_output "$TARGET" || return 1
  
  if is_output_active "$output"; then
    log_error "$output is already active. Use --change to modify it."
    return 1
  fi
  
  if [[ -z "$W" || -z "$H" ]]; then
    log_error "Resolution required to activate $output"
    echo "Use -r/--resolution or --size" >&2
    return 1
  fi
  
  enable_virtual "$output" "$W" "$H"
}

action_change() {
  local output="VIRTUAL${TARGET}"
  validate_virtual_output "$TARGET" || return 1
  
  if ! is_output_active "$output"; then
    log_error "$output is not active. Use --output to activate it first."
    return 1
  fi
  
  enable_virtual "$output" "$W" "$H"
}

action_auto() {
  if [[ -z "$W" || -z "$H" ]]; then
    log_error "Resolution required. Use -r/--resolution or --size"
    return 1
  fi
  
  local output
  output=$(pick_virtual_output) || return 1
  
  log_info "Auto-selected $output"
  enable_virtual "$output" "$W" "$H"
}

# ============================
# Parameter Validation
# ============================
require_arg() {
  local opt="$1" val="$2"
  if [[ -z "$val" || "$val" == -* ]]; then
    log_error "$opt requires an argument"
    exit 1
  fi
}

require_number() {
  local opt="$1" val="$2"
  require_arg "$opt" "$val"
  if [[ ! "$val" =~ ^[0-9]+$ ]]; then
    log_error "$opt requires a valid number"
    exit 1
  fi
}

parse_orientation() {
  case "$1" in
    L|normal)   ORIENTATION="normal" ;;
    PR|right)   ORIENTATION="right" ;;
    PL|left)    ORIENTATION="left" ;;
    LF|inverted) ORIENTATION="inverted" ;;
    *)
      log_error "Invalid orientation: $1"
      echo "Valid options: L/normal, PR/right, PL/left, LF/inverted" >&2
      exit 1
      ;;
  esac
}

parse_size() {
  local size="$1"
  if [[ ! "$size" =~ ^([0-9]+)x([0-9]+)$ ]]; then
    log_error "Invalid size format. Use WxH (e.g., 1920x1080)"
    exit 1
  fi
  MANUAL_SIZE=true
  MANUAL_W="${BASH_REMATCH[1]}"
  MANUAL_H="${BASH_REMATCH[2]}"
}

parse_position() {
  local pos="$1"
  if [[ ! "$pos" =~ ^[0-9]+x[0-9]+$ ]]; then
    log_error "Invalid position format. Use XxY (e.g., 1920x0)"
    exit 1
  fi
  MANUAL_POS="--pos $pos"
  AUTO_POS=false
}

validate_parameters() {
  # Check incompatible combinations
  if [[ "$ACTION" == "output" && -z "$RES_KEY" && ! $MANUAL_SIZE ]]; then
    log_error "--output requires either -r/--resolution or --size"
    return 1
  fi
  
  if [[ -n "$RES_KEY" && $MANUAL_SIZE == true ]]; then
    log_error "Cannot use both -r/--resolution and --size"
    return 1
  fi
  
  if [[ "$ACTION" == "change" && -z "$TARGET" ]]; then
    log_error "--change requires a target number"
    return 1
  fi
  
  if [[ "$ACTION" == "off" && -z "$TARGET" ]]; then
    log_error "--off requires a target number"
    return 1
  fi
  
  if [[ "$ACTION" == "purge" && -z "$TARGET" ]]; then
    log_error "--purge requires a target number"
    return 1
  fi
  
  # Validate positioning conflicts
  local pos_count=0
  [[ -n "$MANUAL_POS" ]] && ((pos_count++))
  ! $AUTO_POS && [[ -z "$MANUAL_POS" ]] && ((pos_count++))
  
  if [[ $pos_count -gt 1 ]]; then
    log_warn "Multiple positioning options specified, manual position takes precedence"
  fi
  
  return 0
}

# ============================
# Argument Parsing
# ============================
ACTION=""
TARGET=""
RES_KEY=""
LIST_MODE=""

[[ $# -eq 0 ]] && { show_help; exit 0; }

while [[ $# -gt 0 ]]; do
  case "$1" in
    --version)  show_version; exit 0 ;;
    --help) show_help; exit 0 ;;
    --debug)  DEBUG=true; shift ;;
    --dry-run)  DRY_RUN=true; shift ;;
    --no-auto)  AUTO_POS=false; shift ;;
    
    -r|--resolution)  require_arg "$1" "${2:-}"; RES_KEY="$2"; shift 2 ;;
    --size) require_arg "$1" "${2:-}"; parse_size "$2"; shift 2 ;;
    -o|--orientation) require_arg "$1" "${2:-}"; parse_orientation "$2"; shift 2 ;;
    
    --pos)  require_arg "$1" "${2:-}"; parse_position "$2"; shift 2 ;;
    --right-of|--left-of|--above|--below)
      require_arg "$1" "${2:-}"; MANUAL_POS="$1 $2"; AUTO_POS=false; shift 2 ;;
    
    --output) require_number "$1" "${2:-}"; ACTION="output"; TARGET="$2"; shift 2 ;;
    -c|--change)  require_number "$1" "${2:-}"; ACTION="change"; TARGET="$2"; shift 2 ;;
    --off)  require_number "$1" "${2:-}"; ACTION="off"; TARGET="$2"; shift 2 ;;
    --off-all)  ACTION="off-all"; shift ;;
    --purge)  require_number "$1" "${2:-}"; ACTION="purge"; TARGET="$2"; shift 2 ;;
    --purge-all)  ACTION="purge-all"; shift ;;
    
    --list)
      ACTION="list"
      if [[ -n "${2:-}" && "$2" != -* ]]; then LIST_MODE="$2"; shift 2
      else LIST_MODE="all"; shift; fi
      ;;
    
    *)
      log_error "Unknown argument: $1"
      echo "Use --help for usage information" >&2
      exit 1
      ;;
  esac
done

# ============================
# Main Execution
# ============================
check_dependencies
validate_parameters || exit 1

# Process resolution
W="" H=""
if $MANUAL_SIZE; then
  W="$MANUAL_W"
  H="$MANUAL_H"
  log_debug "Using manual size: ${W}x${H}"
elif [[ -n "$RES_KEY" ]]; then
  read -r W H <<< "$(get_resolution "$RES_KEY")" || exit 1
  log_debug "Using resolution $RES_KEY: ${W}x${H}"
fi

# Execute action
case "$ACTION" in
  list) action_list || exit 1 ;;
  off)  action_off || exit 1 ;;
  off-all)  action_off_all || exit 1 ;;
  purge)  action_purge || exit 1 ;;
  purge-all)  action_purge_all || exit 1 ;;
  output) action_output || exit 1 ;;
  change) action_change || exit 1 ;;
  "") action_auto || exit 1 ;;
  *)  log_error "No valid action specified"; show_help; exit 1 ;;
esac

exit 0
