#!/bin/bash
# ============================
# vscreen - Virtual Display Manager
# Version: 2.0.0
# ============================

# TODO(logging): Implement journal logging for --debug output
# Currently --debug only outputs to stderr. Should also log to persistent file.
# 
# Implementation:
# - Create logs/journal/vscreen/ directory automatically
# - Append debug output to logs/journal/vscreen/vscreen.log
# - Format: [YYYY-MM-DDTHH:MM:SS] [debug] message
# - Implement log rotation when file exceeds 10MB
# - Keep last 5 rotated logs
#
# labels: logging, debugging, observability

# TODO(state-management): Add snapshot save/load for display configurations
# Users should be able to save and restore virtual display layouts.
#
# Commands:
# - vscreen --save <name>: Save current layout to ~/.config/vscreen/snapshots/<name>.conf
# - vscreen --load <name>: Restore saved layout
# - vscreen --list-snapshots: Show available configurations
# - vscreen --delete-snapshot <name>: Remove snapshot
#
# Snapshot format (TOML):
# [VIRTUAL1]
# resolution=1920x1080
# orientation=normal
# position=1920x0
# active=true
#
# Benefits:
# - Quick layout switching (work/presentation/gaming)
# - Recover from broken display states
# - Share configs between machines
#
# labels: feature, configuration, user-experience

set -o pipefail

# TODO(logging): Implement --debug logging to journal file
# Currently --debug only prints to stderr. Should also save to persistent log.
#
# Requirements:
# - Create logs/journal/vscreen/ directory if needed
# - Append debug output to logs/journal/vscreen/vscreen.log
# - Each line should include ISO 8601 timestamp
# - Format: [2025-12-23T14:30:15-03:00] [debug] message
# - Rotate log file when it exceeds 10MB
# - Keep last 5 rotated logs (vscreen.log.1, .2, etc)
#
# Implementation:
# - Add log_to_journal() function
# - Call it from log_debug() when DEBUG=true
# - Use 'date --iso-8601=seconds' for timestamp
#
# assignees: maintainer
# labels: logging, debugging, observability
# milestone: vscreen-v2.1

# TODO(state-management): Add snapshot save/load functionality
# Allow users to save current virtual display configuration and restore it later.
#
# Planned commands:
# - vscreen --save <name>: Save current state to ~/.config/vscreen/snapshots/<name>.conf
# - vscreen --load <name>: Restore saved state
# - vscreen --list-snapshots: Show available snapshots
# - vscreen --delete-snapshot <name>: Remove saved snapshot
#
# Snapshot format (TOML or simple key=value):
# [VIRTUAL1]
# resolution=1920x1080
# orientation=normal
# position=1920x0
# active=true
#
# [VIRTUAL2]
# resolution=1600x900
# orientation=right
# position=3840x0
# active=true
#
# Benefits:
# - Quick switching between work/presentation/gaming layouts
# - Recover from broken display states
# - Share configurations between machines
#
# assignees: maintainer
# labels: feature, configuration, user-experience
# milestone: vscreen-v2.2

# ============================
# Configuration
# ============================
DRY_RUN=false
DEBUG=false
AUTO_POS=true
ORIENTATION="normal"

# Manual overrides
MANUAL_SIZE=false
MANUAL_W=""
MANUAL_H=""
MANUAL_POS=""

VERSION="2.0.0"

# ============================
# Available Resolutions
# ============================
# ID | NAME | WIDTH | HEIGHT | ASPECT | DESCRIPTION
RESOLUTIONS=(
  "1 FHD   1920 1080 16:9  Desktop"
  "2 HD+   1600 900  16:9  Tablet-large-UI"
  "3 HD    1366 768  16:9  Tablet-comfortable"
  "4 HD10  1280 800  16:10 Tablet-16:10"
  "5 HD+10 1440 900  16:10 Tablet-large-16:10"
  "6 SD    800  450  16:9  Phone"
)

# ============================
# Colors
# ============================
if [[ -t 1 ]]; then
  RED='\033[0;31m'
  GREEN='\033[0;32m'
  YELLOW='\033[1;33m'
  BLUE='\033[0;34m'
  NC='\033[0m'
else
  RED='' GREEN='' YELLOW='' BLUE='' NC=''
fi

# ============================
# Cleanup Handler
# ============================
cleanup() {
  local exit_code=$?
  if [[ $exit_code -ne 0 ]]; then
    log_debug "Script interrupted or failed with code $exit_code"
  fi
  exit $exit_code
}

trap cleanup INT TERM EXIT

# ============================
# Dependency Check
# ============================
check_dependencies() {
  local missing=()
  
  command -v xrandr &> /dev/null || missing+=("xrandr")
  command -v cvt &> /dev/null || missing+=("cvt")
  command -v awk &> /dev/null || missing+=("awk")
  
  if [[ ${#missing[@]} -gt 0 ]]; then
    echo -e "${RED}Error: Missing required dependencies: ${missing[*]}${NC}" >&2
    echo "Install with: sudo apt install x11-xserver-utils gawk" >&2
    exit 1
  fi
}

# ============================
# Logging Helpers
# ============================
log_debug() {
  $DEBUG && echo -e "${BLUE}[debug]${NC} $*" >&2
}

log_info() {
  echo -e "${GREEN}[info]${NC} $*" >&2
}

log_warn() {
  echo -e "${YELLOW}[warn]${NC} $*" >&2
}

log_error() {
  echo -e "${RED}[error]${NC} $*" >&2
}

# ============================
# Command Execution
# ============================
run() {
  if $DRY_RUN; then
    echo -e "${YELLOW}[dry-run]${NC} $*"
    return 0
  else
    log_debug "Executing: $*"
    eval "$@"
    local ret=$?
    if [[ $ret -ne 0 ]]; then
      log_error "Command failed (exit code $ret): $*"
    fi
    return $ret
  fi
}

# ============================
# Help
# ============================
show_help() {
  cat << 'EOF'
vscreen - Virtual Display Manager

USAGE:
  vscreen [OPTIONS] [ACTION]

ACTIONS:
  --output <N>              Activate/modify VIRTUAL<N> output (requires -r or --size)
  -c, --change <N>          Change existing VIRTUAL<N> configuration
  --off <N>                 Disable VIRTUAL<N>
  --off-all                 Disable all virtual displays
  --purge-modes             Remove all custom modes from VIRTUAL outputs
  --list [all|active|free]  List virtual outputs (default: all)
  --version                 Show version information
  --help                    Show this help message

RESOLUTION OPTIONS:
  -r, --resolution <id|name>  Use predefined resolution
  --size WxH                  Use custom resolution (e.g., 1920x1080)

ORIENTATION:
  -o, --orientation <mode>
       L, normal              Landscape (default)
       PR, right              Portrait Right (90° clockwise)
       PL, left               Portrait Left (90° counter-clockwise)
       LF, inverted           Landscape Flipped (180°)

POSITIONING (manual overrides):
  --right-of <output>       Place display to the right of <output>
  --left-of  <output>       Place display to the left of <output>
  --above    <output>       Place display above <output>
  --below    <output>       Place display below <output>
  --pos XxY                 Set absolute position (e.g., 1920x0)

GLOBAL OPTIONS:
  --no-auto                 Disable automatic positioning
  --dry-run                 Show commands without executing
  --debug                   Enable debug output

AVAILABLE RESOLUTIONS:
EOF

  for r in "${RESOLUTIONS[@]}"; do
    IFS=' ' read -r ID NAME W H A DESC <<< "$r"
    printf "  %s: %-6s (%sx%-4s, %-5s) - %s\n" "$ID" "$NAME" "$W" "$H" "$A" "${DESC//-/ }"
  done
  
  echo
  echo "EXAMPLES:"
  echo "  # Activate new virtual display with FHD resolution"
  echo "  vscreen --output 1 -r FHD"
  echo
  echo "  # Activate with custom size and positioning"
  echo "  vscreen --output 2 --size 1600x900 --right-of eDP1"
  echo
  echo "  # Change orientation of existing display"
  echo "  vscreen --change 1 -o right"
  echo
  echo "  # List all virtual outputs"
  echo "  vscreen --list"
  echo
}

show_version() {
  echo "vscreen version $VERSION"
}

# ============================
# Resolution Handling
# ============================
get_resolution() {
  local key="$1"
  
  for r in "${RESOLUTIONS[@]}"; do
    IFS=' ' read -r ID NAME W H A DESC <<< "$r"
    if [[ "$key" == "$ID" || "$key" == "$NAME" ]]; then
      echo "$W $H"
      return 0
    fi
  done
  
  log_error "Invalid resolution: $key"
  return 1
}

# ============================
# Output Discovery (Dynamic)
# ============================
list_virtual_outputs() {
  xrandr 2>/dev/null | awk '/^VIRTUAL[0-9]+/ {print $1}' || {
    log_error "Failed to list virtual outputs"
    return 1
  }
}

list_active_virtuals() {
  xrandr 2>/dev/null | awk '/^VIRTUAL[0-9]+ connected/ {print $1}' || {
    log_error "Failed to list active virtuals"
    return 1
  }
}

list_free_virtuals() {
  comm -23 <(list_virtual_outputs | sort) <(list_active_virtuals | sort)
}

pick_virtual_output() {
  local output
  output=$(list_free_virtuals | head -n 1)
  
  if [[ -z "$output" ]]; then
    log_error "No free VIRTUAL outputs available"
    return 1
  fi
  
  echo "$output"
  return 0
}

validate_virtual_output() {
  local num="$1"
  local output="VIRTUAL${num}"
  
  if ! list_virtual_outputs | grep -q "^${output}$"; then
    log_error "Output $output does not exist"
    return 1
  fi
  
  return 0
}

is_output_active() {
  local output="$1"
  xrandr 2>/dev/null | grep -qE "^${output} connected [0-9]+"
}

# ============================
# Mode Management
# ============================
mode_exists() {
  local name="$1"
  xrandr 2>/dev/null | grep -q "^\s*${name}\s" || return 1
}

create_mode_if_needed() {
  local w="$1" h="$2"
  local full params name
  
  log_debug "Creating mode for ${w}x${h}"
  
  full=$(cvt "$w" "$h" 60 2>&1) || {
    log_error "Failed to calculate modeline with cvt"
    return 1
  }
  
  params=$(echo "$full" | sed -n 's/.*Modeline //p')
  
  if [[ -z "$params" ]]; then
    log_error "Failed to parse modeline from cvt output"
    return 1
  fi
  
  name=$(echo "$params" | awk '{print $1}' | tr -d '"')
  
  if [[ -z "$name" ]]; then
    log_error "Failed to extract mode name"
    return 1
  fi
  
  if ! mode_exists "$name"; then
    log_debug "Mode $name does not exist, creating..."
    run xrandr --newmode $params || {
      log_error "Failed to create mode $name"
      return 1
    }
  else
    log_debug "Mode $name already exists"
  fi
  
  echo "$name"
  return 0
}

purge_modes() {
  local virtuals modes_removed=0
  
  # TODO(cleanup-improvement): Make --purge-modes remove inactive virtual outputs
  # Currently only removes mode associations but leaves disconnected outputs.
  # After purge, should leave only VIRTUAL1 available (reset to clean state).
  #
  # This would fix the "ghost displays" problem where tests leave many
  # VIRTUALs in xrandr even after --off-all.
  #
  # Approach 1: After removing modes, also do:
  #   for v in $(list_virtual_outputs); do
  #     if ! is_output_active "$v"; then
  #       # xrandr doesn't have --remove-output, so we can't actually delete them
  #       # Virtual outputs persist until X restart
  #     fi
  #   done
  #
  # Approach 2: Document that user must restart X session to fully reset
  #
  # Approach 3: Before any vscreen operation, save xrandr state to allow restore
  #
  # Note: Intel driver creates virtual outputs dynamically and doesn't provide
  # a way to remove them via xrandr. They persist until X server restarts.
  #
  # assignees: maintainer
  # labels: cleanup, user-experience, limitation
  # milestone: vscreen-v2.1
  
  virtuals=$(list_virtual_outputs)
  
  if [[ -z "$virtuals" ]]; then
    log_warn "No virtual outputs found"
    return 0
  fi
  
  for v in $virtuals; do
    log_debug "Processing modes for $v"
    
    # Get all modes for this output
    local modes
    modes=$(xrandr 2>/dev/null | awk "/^$v/,/^[A-Z]/ {if (/^\s+[0-9]+x[0-9]+/) print \$1}")
    
    for m in $modes; do
      log_debug "Removing mode $m from $v"
      run xrandr --delmode "$v" "$m" 2>/dev/null && ((modes_removed++))
    done
  done
  
  log_info "Purged $modes_removed mode associations"
}

# ============================
# Smart Positioning
# ============================
get_smart_position() {
  local target="$1"
  local active ext int
  
  active=$(xrandr --listmonitors 2>/dev/null | awk 'NR>1 {print $NF}' | grep -v "^${target}$")
  
  if [[ -z "$active" ]]; then
    log_debug "No other active monitors, no positioning needed"
    return 0
  fi
  
  # If target is VIRTUAL and there are other VIRTUALs, position right of the last one
  if [[ "$target" =~ VIRTUAL ]]; then
    local prev
    prev=$(echo "$active" | grep VIRTUAL | sort | tail -n 1)
    if [[ -n "$prev" ]]; then
      echo "--right-of $prev"
      return 0
    fi
  fi
  
  # Try external monitor first
  ext=$(echo "$active" | grep -E '^(HDMI|DP|VGA)' | head -n1)
  if [[ -n "$ext" ]]; then
    echo "--right-of $ext"
    return 0
  fi
  
  # Fall back to internal
  int=$(echo "$active" | grep -E '^(eDP|LVDS)' | head -n1)
  if [[ -n "$int" ]]; then
    echo "--right-of $int"
    return 0
  fi
  
  # Last resort: use first active
  local first
  first=$(echo "$active" | head -n1)
  if [[ -n "$first" ]]; then
    echo "--right-of $first"
  fi
}

# ============================
# Display Activation
# ============================
enable_virtual() {
  local output="$1" w="$2" h="$3"
  local mode pos_arg
  
  log_debug "Enabling $output (${w}x${h}, orientation: $ORIENTATION)"
  
  # Determine positioning
  if [[ -n "$MANUAL_POS" ]]; then
    pos_arg="$MANUAL_POS"
    log_debug "Using manual position: $pos_arg"
  elif $AUTO_POS; then
    pos_arg=$(get_smart_position "$output")
    log_debug "Using smart position: $pos_arg"
  fi
  
  # Create and apply mode if dimensions provided
  if [[ -n "$w" && -n "$h" ]]; then
    mode=$(create_mode_if_needed "$w" "$h") || return 1
    
    log_debug "Adding mode $mode to $output"
    run xrandr --addmode "$output" "$mode" || {
      log_error "Failed to add mode $mode to $output"
      return 1
    }
    
    # Small delay to ensure mode is registered
    sleep 0.1
    
    log_info "Activating $output with mode $mode"
    run xrandr --output "$output" --mode "$mode" --rotate "$ORIENTATION" $pos_arg || {
      log_error "Failed to activate $output"
      return 1
    }
  else
    # Just change orientation/position of existing active output
    log_info "Updating $output configuration"
    run xrandr --output "$output" --rotate "$ORIENTATION" $pos_arg || {
      log_error "Failed to update $output"
      return 1
    }
  fi
  
  log_info "Successfully configured $output"
  return 0
}

# ============================
# Parameter Validation
# ============================
validate_parameters() {
  # Check incompatible combinations
  if [[ "$ACTION" == "output" ]] && [[ -z "$RES_KEY" ]] && ! $MANUAL_SIZE; then
    log_error "--output requires either -r/--resolution or --size"
    return 1
  fi
  
  if [[ -n "$RES_KEY" ]] && $MANUAL_SIZE; then
    log_error "Cannot use both -r/--resolution and --size"
    return 1
  fi
  
  if [[ "$ACTION" == "change" ]] && [[ -z "$TARGET" ]]; then
    log_error "--change requires a target number"
    return 1
  fi
  
  if [[ "$ACTION" == "off" ]] && [[ -z "$TARGET" ]]; then
    log_error "--off requires a target number"
    return 1
  fi
  
  # Validate positioning conflicts
  local pos_count=0
  [[ -n "$MANUAL_POS" ]] && ((pos_count++))
  ! $AUTO_POS && ((pos_count++))
  
  if [[ $pos_count -gt 1 ]]; then
    log_warn "Multiple positioning options specified, manual position takes precedence"
  fi
  
  return 0
}

# ============================
# Argument Parsing
# ============================
if [[ $# -eq 0 ]]; then
  show_help
  exit 0
fi

ACTION=""
TARGET=""
RES_KEY=""
LIST_MODE=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --version)
      show_version
      exit 0
      ;;
    --help)
      show_help
      exit 0
      ;;
    -r|--resolution)
      if [[ -z "${2:-}" || "$2" == -* ]]; then
        log_error "-r/--resolution requires an argument"
        exit 1
      fi
      RES_KEY="$2"
      shift 2
      ;;
    --size)
      if [[ -z "${2:-}" ]]; then
        log_error "--size requires an argument"
        exit 1
      fi
      if [[ ! "$2" =~ ^([0-9]+)x([0-9]+)$ ]]; then
        log_error "Invalid size format. Use WxH (e.g., 1920x1080)"
        exit 1
      fi
      MANUAL_SIZE=true
      MANUAL_W="${BASH_REMATCH[1]}"
      MANUAL_H="${BASH_REMATCH[2]}"
      shift 2
      ;;
    --output)
      if [[ -z "${2:-}" || "$2" == -* ]]; then
        log_error "--output requires a number"
        exit 1
      fi
      if [[ ! "$2" =~ ^[0-9]+$ ]]; then
        log_error "--output requires a valid number"
        exit 1
      fi
      ACTION="output"
      TARGET="$2"
      shift 2
      ;;
    -c|--change)
      if [[ -z "${2:-}" || "$2" == -* ]]; then
        log_error "-c/--change requires a number"
        exit 1
      fi
      if [[ ! "$2" =~ ^[0-9]+$ ]]; then
        log_error "--change requires a valid number"
        exit 1
      fi
      ACTION="change"
      TARGET="$2"
      shift 2
      ;;
    --off)
      if [[ -z "${2:-}" || "$2" == -* ]]; then
        log_error "--off requires a number"
        exit 1
      fi
      if [[ ! "$2" =~ ^[0-9]+$ ]]; then
        log_error "--off requires a valid number"
        exit 1
      fi
      ACTION="off"
      TARGET="$2"
      shift 2
      ;;
    --off-all)
      ACTION="off-all"
      shift
      ;;
    --purge-modes)
      ACTION="purge"
      shift
      ;;
    --list)
      ACTION="list"
      if [[ -n "${2:-}" && "$2" != -* ]]; then
        LIST_MODE="$2"
        shift 2
      else
        LIST_MODE="all"
        shift 1
      fi
      ;;
    -o|--orientation)
      if [[ -z "${2:-}" || "$2" == -* ]]; then
        log_error "-o/--orientation requires an argument"
        exit 1
      fi
      case "$2" in
        L|normal) ORIENTATION="normal";;
        PR|right) ORIENTATION="right";;
        PL|left) ORIENTATION="left";;
        LF|inverted) ORIENTATION="inverted";;
        *)
          log_error "Invalid orientation: $2"
          echo "Valid options: L/normal, PR/right, PL/left, LF/inverted"
          exit 1
          ;;
      esac
      shift 2
      ;;
    --right-of|--left-of|--above|--below)
      if [[ -z "${2:-}" || "$2" == -* ]]; then
        log_error "$1 requires an output name"
        exit 1
      fi
      MANUAL_POS="$1 $2"
      AUTO_POS=false
      shift 2
      ;;
    --pos)
      if [[ -z "${2:-}" ]]; then
        log_error "--pos requires coordinates"
        exit 1
      fi
      if [[ ! "$2" =~ ^[0-9]+x[0-9]+$ ]]; then
        log_error "Invalid position format. Use XxY (e.g., 1920x0)"
        exit 1
      fi
      MANUAL_POS="--pos $2"
      AUTO_POS=false
      shift 2
      ;;
    --no-auto)
      AUTO_POS=false
      shift
      ;;
    --dry-run)
      DRY_RUN=true
      shift
      ;;
    --debug)
      DEBUG=true
      shift
      ;;
    *)
      log_error "Unknown argument: $1"
      echo "Use --help for usage information"
      exit 1
      ;;
  esac
done

# ============================
# Main Execution
# ============================
check_dependencies

# Validate parameters before proceeding
validate_parameters || exit 1

# ============================
# Execute Actions
# ============================
case "$ACTION" in
  list)
    case "$LIST_MODE" in
      all)
        list_virtual_outputs || exit 1
        ;;
      active)
        list_active_virtuals || exit 1
        ;;
      free)
        list_free_virtuals || exit 1
        ;;
      *)
        log_error "Invalid list mode: $LIST_MODE"
        echo "Valid modes: all, active, free"
        exit 1
        ;;
    esac
    exit 0
    ;;
    
  off)
    OUTPUT="VIRTUAL${TARGET}"
    validate_virtual_output "$TARGET" || exit 1
    
    if ! is_output_active "$OUTPUT"; then
      log_warn "$OUTPUT is not active"
      exit 0
    fi
    
    log_info "Disabling $OUTPUT"
    run xrandr --output "$OUTPUT" --off || exit 1
    log_info "$OUTPUT disabled successfully"
    exit 0
    ;;
    
  off-all)
    ACTIVE=$(list_active_virtuals)
    
    if [[ -z "$ACTIVE" ]]; then
      log_info "No active virtual displays to disable"
      exit 0
    fi
    
    for v in $ACTIVE; do
      log_info "Disabling $v"
      run xrandr --output "$v" --off || log_warn "Failed to disable $v"
    done
    
    log_info "All virtual displays disabled"
    exit 0
    ;;
    
  purge)
    purge_modes
    exit 0
    ;;
esac

# ============================
# Resolution Processing
# ============================
W=""
H=""

if $MANUAL_SIZE; then
  W="$MANUAL_W"
  H="$MANUAL_H"
  log_debug "Using manual size: ${W}x${H}"
elif [[ -n "$RES_KEY" ]]; then
  read -r W H <<< "$(get_resolution "$RES_KEY")" || exit 1
  log_debug "Using resolution $RES_KEY: ${W}x${H}"
fi

# ============================
# Output/Change Actions
# ============================
if [[ "$ACTION" == "output" ]]; then
  OUTPUT="VIRTUAL${TARGET}"
  
  # Validate output exists
  validate_virtual_output "$TARGET" || exit 1
  
  # Check if already active
  if is_output_active "$OUTPUT"; then
    log_error "$OUTPUT is already active. Use --change to modify it."
    exit 1
  fi
  
  # Resolution is required for new activation
  if [[ -z "$W" || -z "$H" ]]; then
    log_error "Resolution required to activate $OUTPUT"
    echo "Use -r/--resolution or --size"
    exit 1
  fi
  
  enable_virtual "$OUTPUT" "$W" "$H" || exit 1
  exit 0
fi

if [[ "$ACTION" == "change" ]]; then
  OUTPUT="VIRTUAL${TARGET}"
  
  # Validate output exists
  validate_virtual_output "$TARGET" || exit 1
  
  # Check if output is active
  if ! is_output_active "$OUTPUT"; then
    log_error "$OUTPUT is not active. Use --output to activate it first."
    exit 1
  fi
  
  # For change, resolution is optional
  enable_virtual "$OUTPUT" "$W" "$H" || exit 1
  exit 0
fi

# ============================
# Legacy behavior (auto-pick output)
# ============================
if [[ -z "$ACTION" ]]; then
  # This path requires resolution
  if [[ -z "$W" || -z "$H" ]]; then
    log_error "Resolution required. Use -r/--resolution or --size"
    exit 1
  fi
  
  OUTPUT=$(pick_virtual_output) || exit 1
  
  log_info "Auto-selected $OUTPUT"
  enable_virtual "$OUTPUT" "$W" "$H" || exit 1
  exit 0
fi

# Should not reach here
log_error "No valid action specified"
show_help
exit 1