#!/bin/bash
# ============================
# vscreen - Virtual Display Manager
# Version: 3.0.0
# ============================

set -o pipefail

# ============================
# Configuration
# ============================
VERSION="3.0.0"

DRY_RUN=false
DEBUG=false
ORIENTATION="normal"
ORIENTATION_SET=false
POSITION_SET=false

SIGILS="${SIGILS:-$HOME/.local/sigils}"
CONFIG_DIR="$SIGILS/spells/vscreen/config"
CONFIG_FILE="$CONFIG_DIR/resolutions"

# ============================
# Default Resolutions
# ============================
DEFAULT_RESOLUTIONS=(
  "FHD   1920 1080 16:9  Desktop"
  "HD+   1600 900  16:9  Tablet-large-UI"
  "HD    1366 768  16:9  Tablet-comfortable"
  "HD10  1280 800  16:10 Tablet-16:10"
  "HD+10 1440 900  16:10 Tablet-large-16:10"
  "SD    800  450  16:9  Phone"
)

# ============================
# Colors
# ============================
if [[ -t 1 ]]; then
  RED='\033[0;31m'
  GREEN='\033[0;32m'
  YELLOW='\033[1;33m'
  BLUE='\033[0;34m'
  CYAN='\033[0;36m'
  BOLD='\033[1m'
  NC='\033[0m'
else
  RED='' GREEN='' YELLOW='' BLUE='' CYAN='' BOLD='' NC=''
fi

# ============================
# Cleanup Handler
# ============================
cleanup() {
  local exit_code=$?
  if [[ $exit_code -ne 0 ]]; then
    log_debug "Script exited with code $exit_code"
  fi
  exit $exit_code
}

trap cleanup INT TERM EXIT

# ============================
# Logging Helpers
# ============================
log_debug() { $DEBUG && echo -e "${BLUE}[debug]${NC} $*" >&2; }
log_info()  { echo -e "${GREEN}[info]${NC} $*" >&2; }
log_warn()  { echo -e "${YELLOW}[warn]${NC} $*" >&2; }
log_error() { echo -e "${RED}[error]${NC} $*" >&2; }

# ============================
# Command Execution
# ============================
run() {
  if $DRY_RUN; then
    echo -e "${YELLOW}[dry-run]${NC} $*" >&2
    return 0
  fi
  log_debug "Executing: $*"
  eval "$@"
  local ret=$?
  if [[ $ret -ne 0 ]]; then
    log_error "Command failed (exit code $ret): $*"
  fi
  return $ret
}

# ============================
# Dependency Check
# ============================
check_dependencies() {
  local missing=()
  command -v xrandr &>/dev/null || missing+=("xrandr")
  command -v cvt &>/dev/null   || missing+=("cvt")
  command -v awk &>/dev/null   || missing+=("awk")

  if [[ ${#missing[@]} -gt 0 ]]; then
    log_error "Missing required dependencies: ${missing[*]}"
    echo "Install with: sudo apt install x11-xserver-utils gawk" >&2
    exit 1
  fi
}

# ============================
# Config File Management
# ============================
ensure_config() {
  if [[ ! -d "$CONFIG_DIR" ]]; then
    log_debug "Creating config directory: $CONFIG_DIR"
    mkdir -p "$CONFIG_DIR"
  fi

  if [[ ! -f "$CONFIG_FILE" ]]; then
    log_debug "Creating default config: $CONFIG_FILE"
    {
      echo "# vscreen resolution presets"
      echo "# Format: NAME WIDTH HEIGHT RATIO DESCRIPTION"
      echo "#"
      for r in "${DEFAULT_RESOLUTIONS[@]}"; do
        echo "$r"
      done
    } > "$CONFIG_FILE"
  fi
}

load_resolutions() {
  RESOLUTIONS=()
  ensure_config
  while IFS= read -r line; do
    # Skip comments and empty lines
    [[ "$line" =~ ^[[:space:]]*# ]] && continue
    [[ -z "${line// /}" ]] && continue
    RESOLUTIONS+=("$line")
  done < "$CONFIG_FILE"
  log_debug "Loaded ${#RESOLUTIONS[@]} resolutions from config"
  return 0
}

save_config() {
  ensure_config
  local _rc
  {
    echo "# vscreen resolution presets"
    echo "# Format: NAME WIDTH HEIGHT RATIO DESCRIPTION"
    echo "#"
    for r in "${RESOLUTIONS[@]}"; do
      echo "$r"
    done
  } > "$CONFIG_FILE"
  _rc=$?
  log_debug "Saved ${#RESOLUTIONS[@]} resolutions to config"
  return $_rc
}

# ============================
# Resolution Handling
# ============================
get_resolution() {
  local key="$1"
  for r in "${RESOLUTIONS[@]}"; do
    IFS=' ' read -r NAME W H A DESC <<< "$r"
    if [[ "$key" == "$NAME" ]]; then
      echo "$W $H"
      return 0
    fi
  done
  log_error "Unknown resolution preset: $key"
  return 1
}

resolution_exists() {
  local key="$1"
  for r in "${RESOLUTIONS[@]}"; do
    IFS=' ' read -r NAME _ _ _ _ <<< "$r"
    [[ "$key" == "$NAME" ]] && return 0
  done
  return 1
}

action_res_list() {
  load_resolutions
  if [[ ${#RESOLUTIONS[@]} -eq 0 ]]; then
    log_info "No resolution presets defined"
    return 0
  fi
  printf "  ${BOLD}%-8s %5s × %-5s %-6s %s${NC}\n" "NAME" "W" "H" "RATIO" "DESCRIPTION"
  for r in "${RESOLUTIONS[@]}"; do
    IFS=' ' read -r NAME W H A DESC <<< "$r"
    printf "  %-8s %5s × %-5s %-6s %s\n" "$NAME" "$W" "$H" "$A" "${DESC//-/ }"
  done
}

action_res_save() {
  local name="$1" w="$2" h="$3" desc="${4:-Custom}"
  load_resolutions

  # Calculate ratio
  local gcd_val ratio
  gcd_val=$(gcd "$w" "$h")
  ratio="$((w / gcd_val)):$((h / gcd_val))"

  local new_entry="$name $w $h $ratio $desc"

  if resolution_exists "$name"; then
    if ! $FORCE; then
      read -r -p "Resolution '$name' already exists. Overwrite? [y/N] " confirm
      [[ "$confirm" =~ ^[yY]$ ]] || { log_info "Aborted"; return 1; }
    fi
    # Replace existing
    local updated=()
    for r in "${RESOLUTIONS[@]}"; do
      IFS=' ' read -r N _ _ _ _ <<< "$r"
      if [[ "$N" == "$name" ]]; then
        updated+=("$new_entry")
      else
        updated+=("$r")
      fi
    done
    RESOLUTIONS=("${updated[@]}")
    log_info "Updated resolution preset: $name (${w}x${h}, $ratio)"
  else
    RESOLUTIONS+=("$new_entry")
    log_info "Saved resolution preset: $name (${w}x${h}, $ratio)"
  fi
  save_config
}

action_res_del() {
  local name="$1"
  load_resolutions

  if ! resolution_exists "$name"; then
    log_error "Resolution preset not found: $name"
    return 1
  fi

  local updated=()
  for r in "${RESOLUTIONS[@]}"; do
    IFS=' ' read -r N _ _ _ _ <<< "$r"
    [[ "$N" != "$name" ]] && updated+=("$r")
  done
  RESOLUTIONS=("${updated[@]}")
  save_config
  log_info "Deleted resolution preset: $name"
}

# ============================
# Math Helpers
# ============================
gcd() {
  local a="$1" b="$2"
  while [[ $b -ne 0 ]]; do
    local t=$b
    b=$((a % b))
    a=$t
  done
  echo "$a"
}

# Round to nearest even number (xrandr prefers even dimensions)
round_even() {
  local val="$1"
  local rounded=$(( (val + 1) / 2 * 2 ))
  echo "$rounded"
}

# ============================
# Ratio Transform
# ============================
apply_ratio() {
  local base_w="$1" base_h="$2" ratio_str="$3"
  local rw rh

  log_debug "Applying ratio '$ratio_str' to ${base_w}x${base_h}"

  if [[ "$ratio_str" =~ ^([0-9]+)x:([0-9]+)$ ]]; then
    # Wx:H → fix height, recalculate width
    rw="${BASH_REMATCH[1]}"
    rh="${BASH_REMATCH[2]}"
    local new_w
    new_w=$(round_even "$((base_h * rw / rh))")
    log_debug "  Fix height=$base_h, W = $base_h × $rw/$rh = $new_w"
    echo "$new_w $base_h"

  elif [[ "$ratio_str" =~ ^([0-9]+):([0-9]+)x$ ]]; then
    # W:Hx → fix width, recalculate height
    rw="${BASH_REMATCH[1]}"
    rh="${BASH_REMATCH[2]}"
    local new_h
    new_h=$(round_even "$((base_w * rh / rw))")
    log_debug "  Fix width=$base_w, H = $base_w × $rh/$rw = $new_h"
    echo "$base_w $new_h"

  else
    log_error "Invalid ratio format: $ratio_str (use Wx:H or W:Hx)"
    return 1
  fi
}

# ============================
# Percentage / Density Transform
# ============================
# Formats:
#   N or N%   → scale: multiply by N/100
#   1/N       → density: divide by N/100 (i.e. multiply by 100/N)
apply_percentage() {
  local base_w="$1" base_h="$2" pct="$3"

  # Strip optional % sign
  pct="${pct%\%}"

  local new_w new_h

  if [[ "$pct" =~ ^1/([0-9]+)$ ]]; then
    # Density notation: 1/N → divide by N/100
    local density="${BASH_REMATCH[1]}"
    if [[ "$density" -eq 0 ]]; then
      log_error "Invalid density: division by zero"
      return 1
    fi
    log_debug "Applying --per 1/$density (density) to ${base_w}x${base_h}"
    new_w=$(round_even "$((base_w * 100 / density))")
    new_h=$(round_even "$((base_h * 100 / density))")
    log_debug "  W = $base_w × 100/$density = $new_w"
    log_debug "  H = $base_h × 100/$density = $new_h"
  elif [[ "$pct" =~ ^[0-9]+$ ]]; then
    # Scale notation: N → multiply by N/100
    if [[ "$pct" -eq 0 ]]; then
      log_error "Invalid percentage: 0"
      return 1
    fi
    log_debug "Applying --per $pct (scale) to ${base_w}x${base_h}"
    new_w=$(round_even "$((base_w * pct / 100))")
    new_h=$(round_even "$((base_h * pct / 100))")
    log_debug "  W = $base_w × $pct/100 = $new_w"
    log_debug "  H = $base_h × $pct/100 = $new_h"
  else
    log_error "Invalid --per format: $pct (use N, N%, or 1/N)"
    return 1
  fi

  echo "$new_w $new_h"
}

# ============================
# Output Discovery
# ============================
list_virtual_outputs() {
  xrandr 2>/dev/null | awk '/^VIRTUAL[0-9]+/{print $1}' | sort -V || {
    log_error "Failed to list virtual outputs"
    return 1
  }
}

list_active_virtuals() {
  xrandr 2>/dev/null | awk '/^VIRTUAL[0-9]+ connected [0-9]+/{print $1}' | sort -V || {
    log_error "Failed to list active virtuals"
    return 1
  }
}

list_free_virtuals() {
  local active
  active=$(list_active_virtuals)

  if [[ -z "$active" ]]; then
    list_virtual_outputs
  else
    list_virtual_outputs | grep -vFxf <(echo "$active")
  fi
}

pick_virtual_output() {
  local output
  output=$(list_free_virtuals | head -n 1)
  if [[ -z "$output" ]]; then
    log_error "No free VIRTUAL outputs available"
    return 1
  fi
  echo "$output"
}

validate_virtual_output() {
  local output="$1"
  if [[ ! "$output" =~ ^VIRTUAL[0-9]+$ ]]; then
    log_error "Invalid output format: $output (expected VIRTUAL<N>)"
    return 1
  fi
  if ! list_virtual_outputs | grep -q "^${output}$"; then
    log_error "Output $output does not exist"
    return 1
  fi
  return 0
}

is_output_active() {
  local output="$1"
  xrandr 2>/dev/null | grep -qE "^${output} connected (primary )?[0-9]+"
}

# ============================
# Geometry Parsing
# ============================
# Returns: W H X Y for a given output
get_output_geometry() {
  local target="$1"
  local line
  line=$(xrandr 2>/dev/null | grep -E "^${target} connected" | head -n1)

  if [[ -z "$line" ]]; then
    log_error "Cannot get geometry for $target (not active?)"
    return 1
  fi

  if [[ "$line" =~ ([0-9]+)x([0-9]+)([+-][0-9]+)([+-][0-9]+) ]]; then
    local w="${BASH_REMATCH[1]}"
    local h="${BASH_REMATCH[2]}"
    local xraw="${BASH_REMATCH[3]}"
    local yraw="${BASH_REMATCH[4]}"
    local x="${xraw#+}"
    local y="${yraw#+}"

    log_debug "Geometry of $target: ${w}x${h}${xraw}${yraw}"
    echo "$w $h $x $y"
    return 0
  fi

  log_error "Failed to parse geometry for $target"
  return 1
}

# Get current mode (resolution) of an active output
get_output_mode() {
  local target="$1"
  local line
  line=$(xrandr 2>/dev/null | grep -E "^${target} connected" | head -n1)

  [[ -z "$line" ]] && return 1

  if [[ "$line" =~ ([0-9]+)x([0-9]+)([+-][0-9]+)([+-][0-9]+) ]]; then
    echo "${BASH_REMATCH[1]} ${BASH_REMATCH[2]}"
    return 0
  fi

  return 1
}

# Returns positioning dimensions after applying a rotation.
# For right/left, the effective width/height are swapped.
effective_dims_for_orientation() {
  local w="$1" h="$2" orient="$3"
  if [[ "$orient" == "right" || "$orient" == "left" ]]; then
    echo "$h $w"
  else
    echo "$w $h"
  fi
}

# Returns current rotation for an active output: normal|left|right|inverted
get_output_orientation() {
  local target="$1"
  local line
  line=$(xrandr 2>/dev/null | grep -E "^${target} connected" | head -n1)

  [[ -z "$line" ]] && return 1

  # xrandr prints the current rotation *before* the "(normal left inverted right ...)" list.
  # If there's no explicit token, the current rotation is "normal".
  local pre="${line%%(*}"

  if [[ "$pre" =~ (left|right|inverted)[[:space:]]*$ ]]; then
    echo "${BASH_REMATCH[1]}"
  else
    echo "normal"
  fi
}

action_get_pos() {
  local filter="$1"

  local line
  while IFS= read -r line; do
    local output
    output=$(echo "$line" | awk '{print $1}')

    [[ -z "$output" ]] && continue

    if [[ "$line" =~ ([0-9]+)x([0-9]+)([+-][0-9]+)([+-][0-9]+) ]]; then
      if [[ -z "$filter" || "$filter" == "$output" ]]; then
        local w="${BASH_REMATCH[1]}"
        local h="${BASH_REMATCH[2]}"
        local x="${BASH_REMATCH[3]#+}"
        local y="${BASH_REMATCH[4]#+}"
        printf "%-14s %sx%s%+d%+d\\n" "$output" "$w" "$h" "$x" "$y"
      fi
    fi
  done < <(xrandr 2>/dev/null | grep -E '^[A-Za-z].* connected (primary )?[0-9]')
}


# ============================
# Output Discovery & Framebuffer
# ============================
output_exists() {
  local output="$1"
  xrandr 2>/dev/null | grep -qE "^${output} (connected|disconnected)"
}

validate_active_output() {
  local output="$1"
  if ! output_exists "$output"; then
    log_error "Unknown output: $output"
    return 1
  fi
  if ! is_output_active "$output"; then
    log_error "Output is not active: $output"
    return 1
  fi
  return 0
}

list_active_outputs_all() {
  xrandr 2>/dev/null | grep -E '^[A-Za-z].* connected (primary )?[0-9]+' | awk '{print $1}'
}

get_framebuffer_info() {
  # Returns: current_w current_h max_w max_h
  local line
  line=$(xrandr 2>/dev/null | head -n 1)
  if [[ "$line" =~ current[[:space:]]+([0-9]+)[[:space:]]+x[[:space:]]+([0-9]+),[[:space:]]+maximum[[:space:]]+([0-9]+)[[:space:]]+x[[:space:]]+([0-9]+) ]]; then
    echo "${BASH_REMATCH[1]} ${BASH_REMATCH[2]} ${BASH_REMATCH[3]} ${BASH_REMATCH[4]}"
    return 0
  fi
  log_error "Failed to parse framebuffer from xrandr header"
  return 1
}

ensure_framebuffer_for_plan() {
  # Reads: name w h x y (one per line) from stdin
  local cur_w cur_h max_w max_h
  read -r cur_w cur_h max_w max_h <<< "$(get_framebuffer_info)" || return 1

  local req_w="$cur_w"
  local req_h="$cur_h"

  local name w h x y
  while read -r name w h x y; do
    [[ -z "$name" ]] && continue
    local right=$((x + w))
    local bottom=$((y + h))
    (( right > req_w )) && req_w=$right
    (( bottom > req_h )) && req_h=$bottom
  done

  if (( req_w > max_w || req_h > max_h )); then
    log_error "Required framebuffer ${req_w}x${req_h} exceeds maximum ${max_w}x${max_h}"
    return 1
  fi

  if (( req_w > cur_w || req_h > cur_h )); then
    log_debug "Expanding framebuffer: ${cur_w}x${cur_h} -> ${req_w}x${req_h}"
    run xrandr --fb "${req_w}x${req_h}" || return 1
  fi

  return 0
}

ensure_framebuffer_for_rect() {
  # Ensures the framebuffer can contain:
  #   - all current active outputs (excluding $name)
  #   - plus a planned rect ($x,$y,$w,$h) for $name
  local name="$1" x="$2" y="$3" w="$4" h="$5"

  local plan=""
  local o
  for o in $(list_active_outputs_all); do
    [[ "$o" == "$name" ]] && continue
    local gw gh gx gy
    if read -r gw gh gx gy <<< "$(get_output_geometry "$o" 2>/dev/null)"; then
      plan+="${o} ${gw} ${gh} ${gx} ${gy}
"
    fi
  done
  plan+="${name} ${w} ${h} ${x} ${y}
"

  printf "%b" "$plan" | ensure_framebuffer_for_plan
}

rects_overlap() {
  # args: x1 y1 w1 h1 x2 y2 w2 h2
  local x1="$1" y1="$2" w1="$3" h1="$4" x2="$5" y2="$6" w2="$7" h2="$8"
  local r1=$((x1 + w1))
  local b1=$((y1 + h1))
  local r2=$((x2 + w2))
  local b2=$((y2 + h2))

  (( x1 < r2 && r1 > x2 && y1 < b2 && b1 > y2 ))
}

abs_i() {
  local v="$1"
  (( v < 0 )) && v=$(( -v ))
  echo "$v"
}

csv_to_array() {
  # prints one token per line
  local csv="$1"
  csv="${csv// /}"
  IFS=',' read -r -a _tmp <<< "$csv"
  local t
  for t in "${_tmp[@]}"; do
    [[ -n "$t" ]] && echo "$t"
  done
}
# ============================
# Position Calculation
# ============================
calculate_position() {
  local direction="$1"   # right-of, left-of, above-of, below-of
  local ref_output="$2"  # reference output name
  local alignment="$3"   # top/center/bottom or left/center/right
  local vw="$4" vh="$5"  # virtual display dimensions

  log_debug "Calculating position: $direction $ref_output $alignment (virtual: ${vw}x${vh})"

  local ref_geom
  ref_geom=$(get_output_geometry "$ref_output") || return 1
  IFS=' ' read -r rw rh rx ry <<< "$ref_geom"

  log_debug "  Reference $ref_output: ${rw}x${rh}+${rx}+${ry}"

  local px py

  case "$direction" in
    right-of)
      px=$((rx + rw))
      case "$alignment" in
        top)    py=$ry ;;
        center) py=$((ry + (rh - vh) / 2)) ;;
        bottom) py=$((ry + rh - vh)) ;;
      esac
      ;;
    left-of)
      px=$((rx - vw))
      case "$alignment" in
        top)    py=$ry ;;
        center) py=$((ry + (rh - vh) / 2)) ;;
        bottom) py=$((ry + rh - vh)) ;;
      esac
      ;;
    above-of)
      py=$((ry - vh))
      case "$alignment" in
        left)   px=$rx ;;
        center) px=$((rx + (rw - vw) / 2)) ;;
        right)  px=$((rx + rw - vw)) ;;
      esac
      ;;
    below-of)
      py=$((ry + rh))
      case "$alignment" in
        left)   px=$rx ;;
        center) px=$((rx + (rw - vw) / 2)) ;;
        right)  px=$((rx + rw - vw)) ;;
      esac
      ;;
  esac

  if [[ $px -lt 0 || $py -lt 0 ]]; then
    log_warn "Calculated position has negative coordinates: ${px}x${py}"
  fi

  log_debug "  Calculated position: --pos ${px}x${py}"
  echo "--pos ${px}x${py}"
}

# ============================
# Smart Positioning (default)
# ============================
get_smart_position() {
  local target="$1" vw="$2" vh="$3"
  local active
  active=$(xrandr --listmonitors 2>/dev/null | awk 'NR>1 {print $NF}' | grep -v "^${target}$")

  [[ -z "$active" ]] && return 0

  # If target is VIRTUAL and there are other VIRTUALs, position right of the last one
  if [[ "$target" =~ VIRTUAL ]]; then
    local prev
    prev=$(echo "$active" | grep VIRTUAL | sort -V | tail -n 1)
    if [[ -n "$prev" ]]; then
      calculate_position "right-of" "$prev" "center" "$vw" "$vh"
      return 0
    fi
  fi

  # Try external monitor first
  local ext
  ext=$(echo "$active" | grep -E '^(HDMI|DP|VGA)' | head -n1)
  if [[ -n "$ext" ]]; then
    calculate_position "right-of" "$ext" "center" "$vw" "$vh"
    return 0
  fi

  # Fall back to internal
  local int
  int=$(echo "$active" | grep -E '^(eDP|LVDS)' | head -n1)
  if [[ -n "$int" ]]; then
    calculate_position "right-of" "$int" "center" "$vw" "$vh"
    return 0
  fi

  # Last resort: use first active
  local first
  first=$(echo "$active" | head -n1)
  if [[ -n "$first" ]]; then
    calculate_position "right-of" "$first" "center" "$vw" "$vh"
  fi
}

# ============================
# Mode Management
# ============================
mode_exists() {
  local name="$1"
  xrandr 2>/dev/null | grep -q "^\s*${name}\s"
}

create_mode_if_needed() {
  local w="$1" h="$2"
  log_debug "Creating mode for ${w}x${h}"

  local full params name
  full=$(cvt "$w" "$h" 60 2>&1) || {
    log_error "Failed to calculate modeline with cvt"
    return 1
  }

  params=$(echo "$full" | sed -n 's/.*Modeline //p')
  [[ -z "$params" ]] && { log_error "Failed to parse modeline"; return 1; }

  name=$(echo "$params" | awk '{print $1}' | tr -d '"')
  [[ -z "$name" ]] && { log_error "Failed to extract mode name"; return 1; }

  if ! mode_exists "$name"; then
    log_debug "Mode $name does not exist, creating..."
    run xrandr --newmode $params || { log_error "Failed to create mode $name"; return 1; }
  else
    log_debug "Mode $name already exists"
  fi

  echo "$name"
}

# ============================
# Output Purge
# ============================
purge_output() {
  local output="$1"

  log_info "Purging $output"

  local output_block
  output_block=$(xrandr 2>/dev/null | awk '/^'"${output}"' /{found=1} found && /^[A-Z]/ && !/^'"${output}"' /{exit} found{print}')

  if [[ -z "$output_block" ]]; then
    log_warn "Could not find $output in xrandr"
    return 1
  fi

  log_debug "Output block captured:"
  log_debug "$output_block"

  # Disable output first
  log_debug "Disabling $output"
  if ! xrandr --output "$output" --off 2>/dev/null; then
    log_warn "Failed to disable $output (may already be off)"
  fi

  # Extract custom modes
  local modes
  modes=$(echo "$output_block" | grep -oE '[0-9]+x[0-9]+_[0-9.]+' || true)

  if [[ -z "$modes" ]]; then
    log_info "No modes found in $output to remove"
    return 0
  fi

  log_debug "Modes found: $modes"

  local mode_count=0
  local fail_count=0
  for mode in $modes; do
    log_debug "Removing mode $mode from $output"
    if xrandr --delmode "$output" "$mode" 2>/dev/null; then
      ((mode_count++))
      if xrandr --rmmode "$mode" 2>/dev/null; then
        log_info "Mode $mode removed globally"
      else
        log_warn "Mode $mode cannot be removed globally"
      fi
    else
      ((fail_count++))
      log_debug "Failed to remove $mode (may not be attached)"
    fi
  done

  local remaining
  remaining=$(xrandr 2>/dev/null | awk '/^'"${output}"' /{found=1} found{print} found && /^[A-Z]/ && !/^'"${output}"' /{exit}' | grep -oE '[0-9]+x[0-9]+_[0-9.]+' || true)

  if [[ -n "$remaining" ]]; then
    log_warn "Some modes still attached to $output: $remaining"
    return 1
  fi

  log_info "Purge complete for $output ($mode_count modes removed)"
  return 0
}

purge_all_outputs() {
  local virtuals
  virtuals=$(list_virtual_outputs)

  if [[ -z "$virtuals" ]]; then
    log_warn "No virtual outputs found"
    return 0
  fi

  for v in $virtuals; do
    purge_output "$v"
  done

  log_info "All virtual outputs purged"
}

# ============================
# Display Activation
# ============================
enable_virtual() {
  local output="$1" w="$2" h="$3"
  log_debug "Enabling $output (${w}x${h}, orientation: $ORIENTATION)"

  # Determine positioning
  local pos_arg=""

  if [[ -n "$POSITION_CMD" ]]; then
    pos_arg="$POSITION_CMD"
    log_debug "Using specified position: $pos_arg"
  elif [[ -n "$w" && -n "$h" ]]; then
    # Smart default uses the *effective* size after rotation.
    local pw ph
    read -r pw ph <<< "$(effective_dims_for_orientation "$w" "$h" "$ORIENTATION")"
    pos_arg=$(get_smart_position "$output" "$pw" "$ph")
    log_debug "Using smart position: $pos_arg"
  else
    # No dimensions (no mode change) and no explicit position → preserve current position.
    pos_arg=""
  fi

  # Create and apply mode if dimensions provided
  if [[ -n "$w" && -n "$h" ]]; then
    local mode
    mode=$(create_mode_if_needed "$w" "$h") || return 1

    log_debug "Adding mode $mode to $output"
    run xrandr --addmode "$output" "$mode" || {
      log_error "Failed to add mode $mode to $output"
      return 1
    }

    sleep 0.1

    log_info "Activating $output with mode $mode"
    # Ensure the framebuffer can contain the planned position (prevents RRSetCrtcConfig BadValue)
if [[ "$pos_arg" =~ --pos[[:space:]]+(-?[0-9]+)x(-?[0-9]+) ]]; then
  local px="${BASH_REMATCH[1]}"
  local py="${BASH_REMATCH[2]}"
  local eff_w eff_h
  read -r eff_w eff_h <<< "$(effective_dims_for_orientation "$w" "$h" "$ORIENTATION")"
  ensure_framebuffer_for_rect "$output" "$px" "$py" "$eff_w" "$eff_h" || return 1
fi

run xrandr --output "$output" --mode "$mode" --rotate "$ORIENTATION" $pos_arg || {
      log_error "Failed to activate $output"
      return 1
    }
  else
    log_info "Updating $output configuration"
    if [[ "$pos_arg" =~ --pos[[:space:]]+(-?[0-9]+)x(-?[0-9]+) ]]; then
  local px="${BASH_REMATCH[1]}"
  local py="${BASH_REMATCH[2]}"

  # Determine effective size after the requested rotation.
  local cur_w cur_h cur_x cur_y cur_orient base_w base_h eff_w eff_h
  read -r cur_w cur_h cur_x cur_y <<< "$(get_output_geometry "$output")" || return 1
  cur_orient=$(get_output_orientation "$output" || echo "normal")

  # Derive unrotated base size from the current effective size + current orientation.
  if [[ "$cur_orient" == "right" || "$cur_orient" == "left" ]]; then
    base_w="$cur_h"
    base_h="$cur_w"
  else
    base_w="$cur_w"
    base_h="$cur_h"
  fi

  read -r eff_w eff_h <<< "$(effective_dims_for_orientation "$base_w" "$base_h" "$ORIENTATION")"
  ensure_framebuffer_for_rect "$output" "$px" "$py" "$eff_w" "$eff_h" || return 1
fi

run xrandr --output "$output" --rotate "$ORIENTATION" $pos_arg || {
      log_error "Failed to update $output"
      return 1
    }
  fi

  log_info "Successfully configured $output"
}

# ============================
# Layout Management
# ============================
get_autorandr_dir() {
  echo "${HOME}/.config/autorandr"
}

layout_exists() {
  local name="$1"
  [[ -d "$(get_autorandr_dir)/$name" ]]
}

action_layout_list() {
  local ardir
  ardir=$(get_autorandr_dir)

  if [[ ! -d "$ardir" ]]; then
    log_info "No layouts saved (autorandr directory not found)"
    return 0
  fi

  local found=false
  for profile_dir in "$ardir"/*/; do
    [[ -d "$profile_dir" ]] || continue
    local name config
    name=$(basename "$profile_dir")
    config="$profile_dir/config"

    [[ -f "$config" ]] || continue
    found=true

    echo -e "${BOLD}${name}${NC}"

    local current_output=""
    while IFS= read -r line; do
      if [[ "$line" =~ ^output\ (.+) ]]; then
        current_output="${BASH_REMATCH[1]}"
      elif [[ "$line" =~ ^mode\ (.+) && -n "$current_output" ]]; then
        local mode="${BASH_REMATCH[1]}"
        # Read next lines for pos
        :
      elif [[ "$line" =~ ^pos\ (.+) && -n "$current_output" ]]; then
        local pos="${BASH_REMATCH[1]}"
        printf "  %-14s mode %-20s pos %s\n" "$current_output" "$mode" "$pos"
        current_output=""
      fi
    done < "$config"

    echo ""
  done

  if ! $found; then
    log_info "No layouts saved"
  fi
}

action_layout_ascii() {
  local name="$1"
  local ardir
  ardir=$(get_autorandr_dir)
  local config="$ardir/$name/config"

  if [[ ! -f "$config" ]]; then
    log_error "Layout not found: $name"
    return 1
  fi

  # Parse all outputs into arrays
  local -a outputs=() widths=() heights=() xpos=() ypos=()
  local current_output="" current_mode="" current_pos=""

  while IFS= read -r line; do
    if [[ "$line" =~ ^output\ (.+) ]]; then
      # Save previous if complete
      if [[ -n "$current_output" && -n "$current_mode" && -n "$current_pos" ]]; then
        outputs+=("$current_output")
        local mw mh
        mw=$(echo "$current_mode" | sed 's/x.*//' | sed 's/_.*//')
        mh=$(echo "$current_mode" | sed 's/.*x//' | sed 's/_.*//')
        widths+=("$mw")
        heights+=("$mh")
        local px py
        px=$(echo "$current_pos" | sed 's/x.*//')
        py=$(echo "$current_pos" | sed 's/.*x//')
        xpos+=("$px")
        ypos+=("$py")
      fi
      current_output="${BASH_REMATCH[1]}"
      current_mode=""
      current_pos=""
    elif [[ "$line" =~ ^mode\ (.+) ]]; then
      current_mode="${BASH_REMATCH[1]}"
    elif [[ "$line" =~ ^pos\ (.+) ]]; then
      current_pos="${BASH_REMATCH[1]}"
    fi
  done < "$config"

  # Don't forget the last one
  if [[ -n "$current_output" && -n "$current_mode" && -n "$current_pos" ]]; then
    outputs+=("$current_output")
    local mw mh
    mw=$(echo "$current_mode" | sed 's/x.*//' | sed 's/_.*//')
    mh=$(echo "$current_mode" | sed 's/.*x//' | sed 's/_.*//')
    widths+=("$mw")
    heights+=("$mh")
    local px py
    px=$(echo "$current_pos" | sed 's/x.*//')
    py=$(echo "$current_pos" | sed 's/.*x//')
    xpos+=("$px")
    ypos+=("$py")
  fi

  if [[ ${#outputs[@]} -eq 0 ]]; then
    log_warn "No outputs found in layout $name"
    return 1
  fi

  # Find bounds
  local max_right=0 max_bottom=0
  for i in "${!outputs[@]}"; do
    local right=$((${xpos[$i]} + ${widths[$i]}))
    local bottom=$((${ypos[$i]} + ${heights[$i]}))
    [[ $right -gt $max_right ]] && max_right=$right
    [[ $bottom -gt $max_bottom ]] && max_bottom=$bottom
  done

  # Scale to terminal: ~80 cols, ~24 rows usable
  local term_w=72 term_h=20
  local scale_x=$((max_right / term_w + 1))
  local scale_y=$((max_bottom / term_h + 1))
  # Use the larger scale to preserve proportions
  local scale=$scale_x
  [[ $scale_y -gt $scale ]] && scale=$scale_y

  # Create character grid
  local grid_w=$((max_right / scale + 2))
  local grid_h=$((max_bottom / scale + 2))

  # Initialize grid with spaces
  declare -A grid
  for ((row=0; row<grid_h; row++)); do
    for ((col=0; col<grid_w; col++)); do
      grid[$row,$col]=" "
    done
  done

  # Draw each display
  for i in "${!outputs[@]}"; do
    local sx=$((${xpos[$i]} / scale))
    local sy=$((${ypos[$i]} / scale))
    local sw=$((${widths[$i]} / scale))
    local sh=$((${heights[$i]} / scale))

    # Minimum size
    [[ $sw -lt 4 ]] && sw=4
    [[ $sh -lt 3 ]] && sh=3

    # Draw borders
    # Top border
    grid[$sy,$sx]="┌"
    grid[$sy,$((sx + sw))]="┐"
    for ((c=sx+1; c<sx+sw; c++)); do
      grid[$sy,$c]="─"
    done
    # Bottom border
    grid[$((sy + sh)),$sx]="└"
    grid[$((sy + sh)),$((sx + sw))]="┘"
    for ((c=sx+1; c<sx+sw; c++)); do
      grid[$((sy + sh)),$c]="─"
    done
    # Side borders
    for ((r=sy+1; r<sy+sh; r++)); do
      grid[$r,$sx]="│"
      grid[$r,$((sx + sw))]="│"
    done

    # Label: output name centered
    local label="${outputs[$i]}"
    local res_label="${widths[$i]}×${heights[$i]}"
    local label_col=$((sx + (sw - ${#label}) / 2 + 1))
    local res_col=$((sx + (sw - ${#res_label}) / 2 + 1))
    local name_row=$((sy + sh / 2))
    local res_row=$((sy + sh / 2 + 1))

    [[ $label_col -lt $((sx + 1)) ]] && label_col=$((sx + 1))
    [[ $res_col -lt $((sx + 1)) ]] && res_col=$((sx + 1))

    for ((j=0; j<${#label} && label_col+j<sx+sw; j++)); do
      grid[$name_row,$((label_col + j))]="${label:$j:1}"
    done
    if [[ $((res_row)) -lt $((sy + sh)) ]]; then
      for ((j=0; j<${#res_label} && res_col+j<sx+sw; j++)); do
        grid[$res_row,$((res_col + j))]="${res_label:$j:1}"
      done
    fi
  done

  # Render grid
  echo -e "\n${BOLD}Layout: $name${NC}\n"
  for ((row=0; row<=grid_h; row++)); do
    local line=""
    for ((col=0; col<=grid_w; col++)); do
      line+="${grid[$row,$col]:- }"
    done
    # Only print if not entirely spaces
    [[ -n "${line// /}" ]] && echo "$line"
  done
  echo ""
}

action_layout_save() {
  local name="$1"

  if ! command -v autorandr &>/dev/null; then
    log_error "autorandr is not installed"
    echo "Install with: sudo apt install autorandr" >&2
    return 1
  fi

  if layout_exists "$name"; then
    if ! $FORCE; then
      read -r -p "Layout '$name' already exists. Overwrite? [y/N] " confirm
      [[ "$confirm" =~ ^[yY]$ ]] || { log_info "Aborted"; return 1; }
    fi
  fi

  run autorandr --save "$name" --force || {
    log_error "Failed to save layout"
    return 1
  }
  log_info "Layout saved: $name"
}

action_layout_load() {
  local name="$1"

  if ! command -v autorandr &>/dev/null; then
    log_error "autorandr is not installed"
    echo "Install with: sudo apt install autorandr" >&2
    return 1
  fi

  local ardir
  ardir=$(get_autorandr_dir)
  local config="$ardir/$name/config"

  if [[ ! -f "$config" ]]; then
    log_error "Layout not found: $name"
    return 1
  fi

  log_debug "Loading layout: $name"
  log_debug "Reading profile from: $config"

  # Step 1: Find required VIRTUAL outputs and their modes
  local -a required_virtuals=() required_modes=() required_widths=() required_heights=()
  local current_output="" current_mode=""

  while IFS= read -r line; do
    if [[ "$line" =~ ^output\ (.+) ]]; then
      if [[ -n "$current_output" && -n "$current_mode" && "$current_output" =~ ^VIRTUAL ]]; then
        required_virtuals+=("$current_output")
        required_modes+=("$current_mode")
        local mw mh
        mw=$(echo "$current_mode" | sed 's/x.*//')
        mh=$(echo "$current_mode" | sed 's/.*x//;s/_.*//')
        required_widths+=("$mw")
        required_heights+=("$mh")
      fi
      current_output="${BASH_REMATCH[1]}"
      current_mode=""
    elif [[ "$line" =~ ^mode\ (.+) ]]; then
      current_mode="${BASH_REMATCH[1]}"
    fi
  done < "$config"

  # Last output
  if [[ -n "$current_output" && -n "$current_mode" && "$current_output" =~ ^VIRTUAL ]]; then
    required_virtuals+=("$current_output")
    required_modes+=("$current_mode")
    local mw mh
    mw=$(echo "$current_mode" | sed 's/x.*//')
    mh=$(echo "$current_mode" | sed 's/.*x//;s/_.*//')
    required_widths+=("$mw")
    required_heights+=("$mh")
  fi

  log_debug "Required virtuals: ${required_virtuals[*]}"

  # Step 2: Check availability, remap if needed
  local available
  available=$(list_virtual_outputs)
  local -A remap=()
  local needs_resave=false

  for i in "${!required_virtuals[@]}"; do
    local virt="${required_virtuals[$i]}"
    if echo "$available" | grep -q "^${virt}$"; then
      log_debug "$virt exists, preparing mode..."
    else
      log_warn "$virt does not exist"
      local free
      free=$(list_free_virtuals)
      # Filter out already-used ones
      for v in "${required_virtuals[@]}"; do
        free=$(echo "$free" | grep -v "^${v}$")
      done
      for v in "${remap[@]}"; do
        free=$(echo "$free" | grep -v "^${v}$")
      done
      local next
      next=$(echo "$free" | head -n 1)
      if [[ -z "$next" ]]; then
        log_error "No free virtual output to remap $virt"
        return 1
      fi

      if ! $FORCE; then
        read -r -p "Remap $virt → $next? [y/N] " confirm
        [[ "$confirm" =~ ^[yY]$ ]] || { log_info "Aborted"; return 1; }
      fi

      remap["$virt"]="$next"
      required_virtuals[$i]="$next"
      needs_resave=true
      log_info "Remapping $virt → $next"
    fi
  done

  # Step 3: Create modes and add to outputs
  for i in "${!required_virtuals[@]}"; do
    local virt="${required_virtuals[$i]}"
    local w="${required_widths[$i]}"
    local h="${required_heights[$i]}"

    log_debug "Preparing $virt with mode ${w}x${h}"
    local mode
    mode=$(create_mode_if_needed "$w" "$h") || return 1

    log_debug "Adding mode $mode to $virt"
    run xrandr --addmode "$virt" "$mode" || {
      log_error "Failed to add mode $mode to $virt"
      return 1
    }
  done

  # Step 4: If remapping happened, update the config file
  if $needs_resave; then
    log_debug "Applying remapping to profile config..."
    local temp_config
    temp_config=$(mktemp)
    cp "$config" "$temp_config"

    for old_virt in "${!remap[@]}"; do
      local new_virt="${remap[$old_virt]}"
      sed -i "s/^output ${old_virt}$/output ${new_virt}/" "$temp_config"
    done

    cp "$temp_config" "$config"
    rm -f "$temp_config"
  fi

  # Step 5: Apply layout
  log_info "Applying layout: $name"
  run autorandr --load "$name" || {
    log_error "Failed to apply layout"
    return 1
  }

  # Step 6: Re-save if remapped
  if $needs_resave; then
    log_info "Re-saving layout with remapped outputs"
    run autorandr --save "$name" --force
  fi

  log_info "Layout loaded: $name"
}

action_layout_del() {
  local name="$1"

  local ardir
  ardir=$(get_autorandr_dir)

  if [[ ! -d "$ardir/$name" ]]; then
    log_error "Layout not found: $name"
    return 1
  fi

  rm -rf "$ardir/$name"
  log_info "Layout deleted: $name"
}

# ============================
# Action Handlers
# ============================
action_list() {
  case "$LIST_MODE" in
    all)    list_virtual_outputs ;;
    active) list_active_virtuals ;;
    free)   list_free_virtuals ;;
    *)
      log_error "Invalid list mode: $LIST_MODE"
      echo "Valid modes: all, active, free" >&2
      return 1
      ;;
  esac
}


action_align() {
  local mode="$ALIGN_MODE"
  local ref="$ALIGN_REF"

  # Normalize mode
  case "$mode" in
    center) mode="vcenter" ;;
  esac

  local -a targets=()
  while IFS= read -r t; do
    targets+=("$t")
  done < <(csv_to_array "$ALIGN_LIST")

  if [[ ${#targets[@]} -lt 1 ]]; then
    log_error "--align requires at least one output"
    return 1
  fi

  if [[ -z "$ref" ]]; then
    ref="${targets[0]}"
  fi

  validate_active_output "$ref" || return 1

  local t
  for t in "${targets[@]}"; do
    validate_active_output "$t" || return 1
  done

  # Determine which axis is constrained by the chosen alignment
  local affects="y"   # vcenter/top/bottom affect Y by default
  case "$mode" in
    left|right|hcenter) affects="x" ;;
    top|bottom|vcenter) affects="y" ;;
    *) log_error "Invalid --align mode: $ALIGN_MODE (use left|right|hcenter|top|bottom|vcenter)"; return 1 ;;
  esac

  local nudge_axis="x"
  [[ "$affects" == "x" ]] && nudge_axis="y" || nudge_axis="x"

  # Snapshot all active outputs
  local -a active=()
  while IFS= read -r o; do active+=("$o"); done < <(list_active_outputs_all)

  declare -A W H X Y
  local o
  for o in "${active[@]}"; do
    read -r W["$o"] H["$o"] X["$o"] Y["$o"] <<< "$(get_output_geometry "$o")" || return 1
  done

  local rx="${X[$ref]}" ry="${Y[$ref]}" rw="${W[$ref]}" rh="${H[$ref]}"

  # Apply initial alignment (only one axis)
  for t in "${targets[@]}"; do
    [[ "$t" == "$ref" ]] && continue
    local tw="${W[$t]}" th="${H[$t]}"
    if [[ "$affects" == "x" ]]; then
      case "$mode" in
        left)    X["$t"]=$rx ;;
        right)   X["$t"]=$((rx + rw - tw)) ;;
        hcenter) X["$t"]=$((rx + (rw - tw)/2)) ;;
      esac
    else
      case "$mode" in
        top)     Y["$t"]=$ry ;;
        bottom)  Y["$t"]=$((ry + rh - th)) ;;
        vcenter) Y["$t"]=$((ry + (rh - th)/2)) ;;
      esac
    fi
  done

  # Resolve overlaps by pushing along the perpendicular axis only
  for t in "${targets[@]}"; do
    [[ "$t" == "$ref" ]] && continue

    local iter=0
    local changed=true
    while $changed; do
      changed=false
      ((iter++))
      if (( iter > 80 )); then
        log_error "Overlap resolution exceeded iteration limit for $t"
        return 1
      fi

      for o in "${active[@]}"; do
        [[ "$o" == "$t" ]] && continue

        if rects_overlap "${X[$t]}" "${Y[$t]}" "${W[$t]}" "${H[$t]}" "${X[$o]}" "${Y[$o]}" "${W[$o]}" "${H[$o]}"; then
          if [[ "$nudge_axis" == "x" ]]; then
            local dx_right=$(( X[$o] + W[$o] - X[$t] ))
            local dx_left=$(( X[$o] - (X[$t] + W[$t]) ))
            local ar al
            ar=$(abs_i "$dx_right")
            al=$(abs_i "$dx_left")

            local cand1=$dx_right
            local cand2=$dx_left

            # Prefer candidate that keeps coords non-negative (when possible)
            local nx1=$(( X[$t] + cand1 ))
            local nx2=$(( X[$t] + cand2 ))

            local chosen
            if (( nx1 >= 0 && nx2 < 0 )); then
              chosen=$cand1
            elif (( nx2 >= 0 && nx1 < 0 )); then
              chosen=$cand2
            else
              (( ar <= al )) && chosen=$cand1 || chosen=$cand2
            fi

            X["$t"]=$(( X[$t] + chosen ))
          else
            local dy_down=$(( Y[$o] + H[$o] - Y[$t] ))
            local dy_up=$(( Y[$o] - (Y[$t] + H[$t]) ))
            local ad au
            ad=$(abs_i "$dy_down")
            au=$(abs_i "$dy_up")

            local cand1=$dy_down
            local cand2=$dy_up

            local ny1=$(( Y[$t] + cand1 ))
            local ny2=$(( Y[$t] + cand2 ))

            local chosen
            if (( ny1 >= 0 && ny2 < 0 )); then
              chosen=$cand1
            elif (( ny2 >= 0 && ny1 < 0 )); then
              chosen=$cand2
            else
              (( ad <= au )) && chosen=$cand1 || chosen=$cand2
            fi

            Y["$t"]=$(( Y[$t] + chosen ))
          fi

          changed=true
          break
        fi
      done
    done
  done

  # Ensure framebuffer can contain the planned final layout
  {
    for o in "${active[@]}"; do
      echo "$o ${W[$o]} ${H[$o]} ${X[$o]} ${Y[$o]}"
    done
  } | ensure_framebuffer_for_plan || return 1

  # Apply position updates
  for t in "${targets[@]}"; do
    [[ "$t" == "$ref" ]] && continue
    log_info "Aligning $t: --pos ${X[$t]}x${Y[$t]}"
    run xrandr --output "$t" --pos "${X[$t]}x${Y[$t]}" || return 1
  done

  log_info "Alignment complete"
  return 0
}

action_tile() {
  local axis="$TILE_AXIS"
  local ref="$TILE_REF"
  local explicit_ref=false
  [[ -n "$ref" ]] && explicit_ref=true

  case "$axis" in
    X|x|h|horizontal) axis="x" ;;
    Y|y|v|vertical) axis="y" ;;
    *) log_error "Invalid --tile axis: $TILE_AXIS (use x|y)"; return 1 ;;
  esac

  local -a targets=()
  while IFS= read -r t; do targets+=("$t"); done < <(csv_to_array "$TILE_LIST")

  if [[ ${#targets[@]} -lt 1 ]]; then
    log_error "--tile requires at least one output"
    return 1
  fi

  if ! $explicit_ref; then
    ref="${targets[0]}"
  fi

  validate_active_output "$ref" || return 1

  local -a moved=()
  local t
  for t in "${targets[@]}"; do
    validate_active_output "$t" || return 1
    if $explicit_ref && [[ "$t" == "$ref" ]]; then
      continue
    fi
    moved+=("$t")
  done

  if [[ ${#moved[@]} -eq 0 ]]; then
    log_info "Nothing to tile"
    return 0
  fi

  local -a active=()
  while IFS= read -r o; do active+=("$o"); done < <(list_active_outputs_all)

  declare -A W H X Y
  local o
  for o in "${active[@]}"; do
    read -r W["$o"] H["$o"] X["$o"] Y["$o"] <<< "$(get_output_geometry "$o")" || return 1
  done

  local start_x="${X[$ref]}" start_y="${Y[$ref]}"

  if $explicit_ref; then
    if [[ "$axis" == "x" ]]; then
      start_x=$(( X[$ref] + W[$ref] ))
    else
      start_y=$(( Y[$ref] + H[$ref] ))
    fi
  fi

  local cursor_x="$start_x" cursor_y="$start_y"
  local nudge_axis="y"
  [[ "$axis" == "x" ]] && nudge_axis="y" || nudge_axis="x"

  # Place sequentially
  for t in "${moved[@]}"; do
    X["$t"]=$cursor_x
    Y["$t"]=$cursor_y
    if [[ "$axis" == "x" ]]; then
      cursor_x=$(( cursor_x + W[$t] ))
    else
      cursor_y=$(( cursor_y + H[$t] ))
    fi
  done

  # Resolve overlaps by nudging along perpendicular axis only
  for t in "${moved[@]}"; do
    local iter=0
    local changed=true
    while $changed; do
      changed=false
      ((iter++))
      if (( iter > 120 )); then
        log_error "Overlap resolution exceeded iteration limit for $t"
        return 1
      fi

      for o in "${active[@]}"; do
        [[ "$o" == "$t" ]] && continue

        if rects_overlap "${X[$t]}" "${Y[$t]}" "${W[$t]}" "${H[$t]}" "${X[$o]}" "${Y[$o]}" "${W[$o]}" "${H[$o]}"; then
          if [[ "$nudge_axis" == "x" ]]; then
            local dx_right=$(( X[$o] + W[$o] - X[$t] ))
            X["$t"]=$(( X[$t] + dx_right ))
          else
            local dy_down=$(( Y[$o] + H[$o] - Y[$t] ))
            Y["$t"]=$(( Y[$t] + dy_down ))
          fi
          changed=true
          break
        fi
      done
    done
  done

  {
    for o in "${active[@]}"; do
      echo "$o ${W[$o]} ${H[$o]} ${X[$o]} ${Y[$o]}"
    done
  } | ensure_framebuffer_for_plan || return 1

  for t in "${moved[@]}"; do
    log_info "Tiling $t: --pos ${X[$t]}x${Y[$t]}"
    run xrandr --output "$t" --pos "${X[$t]}x${Y[$t]}" || return 1
  done

  log_info "Tile complete"
  return 0
}

action_pack() {
  local ref="$PACK_REF"
  local explicit_ref=false
  [[ -n "$ref" ]] && explicit_ref=true

  local -a targets=()
  while IFS= read -r t; do targets+=("$t"); done < <(csv_to_array "$PACK_LIST")

  if [[ ${#targets[@]} -lt 1 ]]; then
    log_error "--pack requires at least one output"
    return 1
  fi

  if ! $explicit_ref; then
    ref="${targets[0]}"
  fi

  validate_active_output "$ref" || return 1

  local cur_fb_w cur_fb_h max_fb_w max_fb_h
  read -r cur_fb_w cur_fb_h max_fb_w max_fb_h <<< "$(get_framebuffer_info)" || return 1

  local -a active=()
  while IFS= read -r o; do active+=("$o"); done < <(list_active_outputs_all)

  declare -A W H X Y
  local o
  for o in "${active[@]}"; do
    read -r W["$o"] H["$o"] X["$o"] Y["$o"] <<< "$(get_output_geometry "$o")" || return 1
  done

  local start_x="${X[$ref]}" start_y="${Y[$ref]}"
  # Place items starting to the right of the reference output.
  start_x=$(( start_x + W[$ref] ))

  local cursor_x="$start_x" cursor_y="$start_y"
  local row_h=0

  local -a moved=()
  local t
  for t in "${targets[@]}"; do
    validate_active_output "$t" || return 1
    if [[ "$t" == "$ref" ]]; then
      # Reference stays as anchor
      continue
    fi
    moved+=("$t")
  done

  if [[ ${#moved[@]} -eq 0 ]]; then
    log_info "Nothing to pack"
    return 0
  fi

  for t in "${moved[@]}"; do
    local tw="${W[$t]}" th="${H[$t]}"

    # Wrap row if needed
    if (( cursor_x + tw > cur_fb_w )); then
      cursor_x="$start_x"
      cursor_y=$(( cursor_y + row_h ))
      row_h=0
    fi

    X["$t"]=$cursor_x
    Y["$t"]=$cursor_y

    cursor_x=$(( cursor_x + tw ))
    (( th > row_h )) && row_h="$th"

    # If we still collide with something, drop to next row until free (simple shelf pack)
    local safety=0
    while true; do
      local collided=false
      for o in "${active[@]}"; do
        [[ "$o" == "$t" ]] && continue
        if rects_overlap "${X[$t]}" "${Y[$t]}" "${W[$t]}" "${H[$t]}" "${X[$o]}" "${Y[$o]}" "${W[$o]}" "${H[$o]}"; then
          collided=true
          break
        fi
      done
      $collided || break

      ((safety++))
      if (( safety > 120 )); then
        log_error "Failed to pack $t without collisions"
        return 1
      fi

      cursor_x="$start_x"
      cursor_y=$(( cursor_y + row_h ))
      row_h=0

      X["$t"]=$cursor_x
      Y["$t"]=$cursor_y
      cursor_x=$(( cursor_x + tw ))
      (( th > row_h )) && row_h="$th"
    done
  done

  {
    for o in "${active[@]}"; do
      echo "$o ${W[$o]} ${H[$o]} ${X[$o]} ${Y[$o]}"
    done
  } | ensure_framebuffer_for_plan || return 1

  for t in "${moved[@]}"; do
    log_info "Packing $t: --pos ${X[$t]}x${Y[$t]}"
    run xrandr --output "$t" --pos "${X[$t]}x${Y[$t]}" || return 1
  done

  log_info "Pack complete"
  return 0
}

action_off() {
  local output="$TARGET_OUTPUT"
  validate_virtual_output "$output" || return 1

  if ! is_output_active "$output"; then
    log_warn "$output is not active"
    return 0
  fi

  log_info "Disabling $output"
  run xrandr --output "$output" --off || return 1
  log_info "$output disabled successfully"
}

action_off_all() {
  local active
  active=$(list_active_virtuals)

  if [[ -z "$active" ]]; then
    log_info "No active virtual displays to disable"
    return 0
  fi

  for v in $active; do
    log_info "Disabling $v"
    run xrandr --output "$v" --off || log_warn "Failed to disable $v"
  done

  log_info "All virtual displays disabled"
}

action_purge() {
  local output="$TARGET_OUTPUT"
  validate_virtual_output "$output" || return 1
  purge_output "$output"
}

action_purge_all() {
  purge_all_outputs
}

action_output() {
  local output="$TARGET_OUTPUT"
  validate_virtual_output "$output" || return 1

  if is_output_active "$output"; then
    log_error "$output is already active. Use --change to modify it."
    return 1
  fi

  if [[ -z "$FINAL_W" || -z "$FINAL_H" ]]; then
    log_error "Resolution required to activate $output"
    echo "Use -r/--resolution or -s/--size" >&2
    return 1
  fi

  enable_virtual "$output" "$FINAL_W" "$FINAL_H"
}

action_change() {
  local output="$TARGET_OUTPUT"

  # Auto-select if only one active and no target specified
  if [[ -z "$output" ]]; then
    local actives
    actives=$(list_active_virtuals)
    local count
    count=$(echo "$actives" | grep -c .)
    if [[ $count -eq 1 ]]; then
      output=$(echo "$actives" | head -n1)
      log_debug "Auto-selected only active virtual: $output"
    else
      log_error "--change requires target when multiple virtuals are active"
      return 1
    fi
  fi

  validate_virtual_output "$output" || return 1

  if ! is_output_active "$output"; then
    log_error "$output is not active. Use --output to activate it first."
    return 1
  fi

  # Snapshot current state (for preserving orientation/position when not specified)
  local cur_geom cur_w cur_h cur_x cur_y cur_orient
  cur_geom=$(get_output_geometry "$output") || return 1
  IFS=' ' read -r cur_w cur_h cur_x cur_y <<< "$cur_geom"
  cur_orient=$(get_output_orientation "$output" || echo "normal")

  # If the user didn't pass --orientation, preserve the current rotation.
  if ! $ORIENTATION_SET; then
    ORIENTATION="$cur_orient"
  fi

  # Base "unrotated" dimensions for transforms/positioning
  local base_w="$cur_w" base_h="$cur_h"
  if [[ "$cur_orient" == "right" || "$cur_orient" == "left" ]]; then
    base_w="$cur_h"
    base_h="$cur_w"
  fi

  # Decide whether this change needs to touch the mode (resolution)
  local mode_change=false
  if [[ -n "$RES_KEY" || -n "$SIZE_W" || -n "$RATIO_STR" || -n "$PERCENT_STR" ]]; then
    mode_change=true
  fi

  # If no resolution given, use current as base for transforms.
  if $mode_change; then
    if [[ -z "$FINAL_W" || -z "$FINAL_H" ]]; then
      FINAL_W="$base_w"
      FINAL_H="$base_h"
      log_debug "Using current resolution as base: ${FINAL_W}x${FINAL_H}"
    fi

    # Re-apply transforms
    if [[ -n "$RATIO_STR" ]]; then
      local result
      result=$(apply_ratio "$FINAL_W" "$FINAL_H" "$RATIO_STR") || return 1
      IFS=' ' read -r FINAL_W FINAL_H <<< "$result"
      log_debug "After ratio: ${FINAL_W}x${FINAL_H}"
    fi
    if [[ -n "$PERCENT_STR" ]]; then
      local result
      result=$(apply_percentage "$FINAL_W" "$FINAL_H" "$PERCENT_STR") || return 1
      IFS=' ' read -r FINAL_W FINAL_H <<< "$result"
      log_debug "After percentage: ${FINAL_W}x${FINAL_H}"
    fi
  fi

  # Default behavior for --change: preserve current position unless a position flag was used.
  if ! $POSITION_SET && [[ -z "$POSITION_CMD" ]]; then
    POSITION_CMD="--pos ${cur_x}x${cur_y}"
  fi

  # Calculate deferred position if needed (e.g., --right-of with --change)
  if [[ -n "$POSITION_DIR" && -z "$POSITION_CMD" ]]; then
    local pw ph
    if $mode_change; then
      read -r pw ph <<< "$(effective_dims_for_orientation "$FINAL_W" "$FINAL_H" "$ORIENTATION")"
    else
      read -r pw ph <<< "$(effective_dims_for_orientation "$base_w" "$base_h" "$ORIENTATION")"
    fi
    POSITION_CMD=$(calculate_position "$POSITION_DIR" "$POSITION_REF" "$POSITION_ALIGN" "$pw" "$ph") || return 1
  fi

  if $mode_change; then
    enable_virtual "$output" "$FINAL_W" "$FINAL_H"
  else
    enable_virtual "$output" "" ""
  fi
}

action_auto() {
  if [[ -z "$FINAL_W" || -z "$FINAL_H" ]]; then
    log_error "Resolution required. Use -r/--resolution or -s/--size"
    return 1
  fi

  local output
  output=$(pick_virtual_output) || return 1

  log_info "Auto-selected $output"
  enable_virtual "$output" "$FINAL_W" "$FINAL_H"
}

# ============================
# Help & Version
# ============================
show_help() {
  cat << 'EOF'
vscreen - Virtual Display Manager

USAGE:
  vscreen [OPTIONS] [ACTION]

ACTIONS:
  --output|-o <VIRTUAL*>       Activate a virtual output (requires -r or -s)
  -c|--change [VIRTUAL*]       Change existing virtual (auto-selects if only 1)
  --off <VIRTUAL*>             Disable a virtual output
  --off-all                    Disable all virtual displays
  --purge <VIRTUAL*>           Disable and remove custom modes
  --purge-all                  Purge all virtual displays
  --list [all|active|free]     List virtual outputs (default: all)
  --get-pos [output]           Show display positions
  --align <A,B,...> <mode> [ref] Align outputs (left|right|hcenter|top|bottom|vcenter)
  --tile <x|y> <A,B,...> [ref]  Tile outputs (row/column)
  --pack <A,B,...> [ref]        Pack outputs (simple shelf)

RESOLUTION:
  -r|--resolution [NAME]       List presets (no arg) or use preset
  -r --del <NAME>              Delete a preset
  -s|--size <WxH>              Use explicit resolution
  --save <NAME>                Save resolution (with -s or -o) / layout (alone)
  --desc "text"                Description for --save (default: Custom)

TRANSFORMS:
  --ratio <W:Hx|Wx:H>         Change aspect ratio
                                 W:Hx  fix width, recalculate height
                                 Wx:H  fix height, recalculate width
  --per <N|1/N>                Scale or density transform
                                 N     scale: multiply by N/100 (e.g. 80)
                                 1/N   density: divide by N/100 (e.g. 1/150)

LAYOUT:
  -l|--layout [NAME]           List layouts (no arg) or load layout
  -l --save <NAME>             Save current layout
  -l --del <NAME>              Delete a layout
  -l --ascii <NAME>            Show layout as ASCII diagram

POSITIONING:
  --right-of <output> [align]  Place right (align: top|center|bottom)
  --left-of  <output> [align]  Place left  (align: top|center|bottom)
  --above-of <output> [align]  Place above (align: left|center|right)
  --below-of <output> [align]  Place below (align: left|center|right)
  --pos <XxY>                  Absolute position
  Default alignment: center. Default position: --right-of (smart)

ORIENTATION:
  --orientation <mode>         L|normal, PR|right, PL|left, LF|inverted

GLOBAL:
  --force|-f                   Skip confirmations
  --dry-run                    Show commands without executing
  --debug                      Verbose debug output
  --version                    Show version
  --help                       Show this help

EXAMPLES:
  vscreen -r FHD                                Auto-select, FHD resolution
  vscreen -o VIRTUAL1 -r FHD                    Activate VIRTUAL1 with FHD
  vscreen -o VIRTUAL1 -s 1920x1080              Explicit resolution
  vscreen -c VIRTUAL1 --per 80                  Scale current resolution by 80%
  vscreen -o VIRTUAL1 -s 2000x1200 --per 1/150  Density transform for tablet
  vscreen -c -r FHD --ratio 5:3x                FHD width, 5:3 height ratio
  vscreen -o VIRTUAL1 -r FHD --right-of eDP1 bottom
  vscreen -s 1600x900 --save MyRes              Save resolution preset
  vscreen -s 2000x1200 --per 1/150 --save Tab --desc "Galaxy Tab S6 Lite"
  vscreen -o VIRTUAL1 --save MyRes              Save current resolution of VIRTUAL1
  vscreen --save my-setup                       Save current layout
  vscreen -l my-setup                           Load layout
  vscreen -l --ascii my-setup                   Show layout as ASCII
  vscreen --purge VIRTUAL1
  vscreen --purge-all
EOF
}

show_version() { echo "vscreen version $VERSION"; }

# ============================
# Parameter Parsing Helpers
# ============================
require_arg() {
  local opt="$1" val="$2"
  if [[ -z "$val" || "$val" == -* ]]; then
    log_error "$opt requires an argument"
    exit 1
  fi
}

parse_orientation() {
  ORIENTATION_SET=true
  case "$1" in
    L|normal)    ORIENTATION="normal" ;;
    PR|right)    ORIENTATION="right" ;;
    PL|left)     ORIENTATION="left" ;;
    LF|inverted) ORIENTATION="inverted" ;;
    *)
      log_error "Invalid orientation: $1"
      echo "Valid: L/normal, PR/right, PL/left, LF/inverted" >&2
      exit 1
      ;;
  esac
}

parse_alignment() {
  local direction="$1" align="$2"
  case "$direction" in
    right-of|left-of)
      case "$align" in
        top|center|bottom) echo "$align" ;;
        *) log_error "Invalid alignment for $direction: $align (use top|center|bottom)"; exit 1 ;;
      esac
      ;;
    above-of|below-of)
      case "$align" in
        left|center|right) echo "$align" ;;
        *) log_error "Invalid alignment for $direction: $align (use left|center|right)"; exit 1 ;;
      esac
      ;;
  esac
}

# ============================
# Argument Parsing
# ============================
ACTION=""
TARGET_OUTPUT=""
RES_KEY=""
SAVE_NAME=""
DEL_NAME=""
LIST_MODE=""
SIZE_W="" SIZE_H=""
RATIO_STR=""
PERCENT_STR=""
POSITION_DIR=""
POSITION_REF=""
POSITION_ALIGN=""
POSITION_CMD=""
LAYOUT_NAME=""
LAYOUT_ACTION=""  # load, save, del, list, ascii
ASCII_NAME=""
FORCE=false
GETPOS_TARGET=""
DESC_STR=""
ALIGN_LIST=""
ALIGN_MODE=""
ALIGN_REF=""
TILE_AXIS=""
TILE_LIST=""
TILE_REF=""
PACK_LIST=""
PACK_REF=""

[[ $# -eq 0 ]] && { show_help; exit 0; }

while [[ $# -gt 0 ]]; do
  case "$1" in
    --version)   show_version; exit 0 ;;
    --help)      show_help; exit 0 ;;
    --debug)     DEBUG=true; shift ;;
    --dry-run)   DRY_RUN=true; shift ;;
    --force|-f)  FORCE=true; shift ;;

    # --- Resolution ---
    -r|--resolution)
      if [[ "${2:-}" == "--del" ]]; then
        require_arg "--del" "${3:-}"
        ACTION="res-del"
        DEL_NAME="$3"
        shift 3
      elif [[ -z "${2:-}" || "$2" == -* ]]; then
        # No arg: list resolutions
        ACTION="res-list"
        shift
      else
        RES_KEY="$2"
        shift 2
      fi
      ;;

    -s|--size)
      require_arg "$1" "${2:-}"
      if [[ ! "$2" =~ ^([0-9]+)x([0-9]+)$ ]]; then
        log_error "Invalid size format. Use WxH (e.g., 1920x1080)"
        exit 1
      fi
      SIZE_W="${BASH_REMATCH[1]}"
      SIZE_H="${BASH_REMATCH[2]}"
      shift 2
      ;;

    # --- Transforms ---
    --ratio)
      require_arg "$1" "${2:-}"
      RATIO_STR="$2"
      shift 2
      ;;

    --per)
      require_arg "$1" "${2:-}"
      PERCENT_STR="$2"
      shift 2
      ;;

    # --- Orientation ---
    --orientation)
      require_arg "$1" "${2:-}"
      parse_orientation "$2"
      shift 2
      ;;

    # --- Positioning ---
    --right-of|--left-of|--above-of|--below-of)
      POSITION_SET=true
      POSITION_DIR="${1#--}"
      require_arg "$1" "${2:-}"
      POSITION_REF="$2"
      shift 2
      # Check for optional alignment
      if [[ -n "${1:-}" && "$1" != -* ]]; then
        POSITION_ALIGN=$(parse_alignment "$POSITION_DIR" "$1")
        shift
      else
        POSITION_ALIGN="center"
      fi
      ;;

    --pos)
      POSITION_SET=true
      require_arg "$1" "${2:-}"
      if [[ ! "$2" =~ ^[0-9]+x[0-9]+$ ]]; then
        log_error "Invalid position format. Use XxY (e.g., 1920x0)"
        exit 1
      fi
      POSITION_CMD="--pos $2"
      shift 2
      ;;

    # --- Actions ---
--align)
  require_arg "$1" "${2:-}"
  require_arg "$1" "${3:-}"
  ACTION="align"
  ALIGN_LIST="$2"
  ALIGN_MODE="$3"
  shift 3
  if [[ -n "${1:-}" && "$1" != -* ]]; then
    ALIGN_REF="$1"
    shift
  fi
  ;;

--tile)
  require_arg "$1" "${2:-}"
  require_arg "$1" "${3:-}"
  ACTION="tile"
  TILE_AXIS="$2"
  TILE_LIST="$3"
  shift 3
  if [[ -n "${1:-}" && "$1" != -* ]]; then
    TILE_REF="$1"
    shift
  fi
  ;;

--pack)
  require_arg "$1" "${2:-}"
  ACTION="pack"
  PACK_LIST="$2"
  shift 2
  if [[ -n "${1:-}" && "$1" != -* ]]; then
    PACK_REF="$1"
    shift
  fi
  ;;
    --output|-o)
      require_arg "$1" "${2:-}"
      ACTION="output"
      TARGET_OUTPUT="$2"
      shift 2
      ;;

    -c|--change)
      ACTION="change"
      if [[ -n "${2:-}" && "${2:-}" =~ ^VIRTUAL ]]; then
        TARGET_OUTPUT="$2"
        shift 2
      else
        # No target, will auto-select
        shift
      fi
      ;;

    --off)
      require_arg "$1" "${2:-}"
      ACTION="off"
      TARGET_OUTPUT="$2"
      shift 2
      ;;

    --off-all)
      ACTION="off-all"
      shift
      ;;

    --purge)
      require_arg "$1" "${2:-}"
      ACTION="purge"
      TARGET_OUTPUT="$2"
      shift 2
      ;;

    --purge-all)
      ACTION="purge-all"
      shift
      ;;

    --list)
      ACTION="list"
      if [[ -n "${2:-}" && "$2" != -* ]]; then
        LIST_MODE="$2"; shift 2
      else
        LIST_MODE="all"; shift
      fi
      ;;

    --get-pos)
      ACTION="get-pos"
      if [[ -n "${2:-}" && "$2" != -* ]]; then
        GETPOS_TARGET="$2"; shift 2
      else
        shift
      fi
      ;;

    # --- Layout ---
    -l|--layout)
      if [[ -z "${2:-}" || "$2" == -* ]]; then
        # No arg: list layouts
        LAYOUT_ACTION="list"
        shift
      elif [[ "${2:-}" == "--save" ]]; then
        require_arg "--save" "${3:-}"
        LAYOUT_ACTION="save"
        LAYOUT_NAME="$3"
        shift 3
      elif [[ "${2:-}" == "--del" ]]; then
        require_arg "--del" "${3:-}"
        LAYOUT_ACTION="del"
        LAYOUT_NAME="$3"
        shift 3
      elif [[ "${2:-}" == "--ascii" ]]; then
        require_arg "--ascii" "${3:-}"
        LAYOUT_ACTION="ascii"
        LAYOUT_NAME="$3"
        shift 3
      else
        LAYOUT_ACTION="load"
        LAYOUT_NAME="$2"
        shift 2
      fi
      ;;

    # --- Save (context-dependent) ---
    --save)
      require_arg "$1" "${2:-}"
      SAVE_NAME="$2"
      shift 2
      ;;

    --desc)
      require_arg "$1" "${2:-}"
      DESC_STR="$2"
      shift 2
      ;;

    *)
      log_error "Unknown argument: $1"
      echo "Use --help for usage information" >&2
      exit 1
      ;;
  esac
done

# ============================
# Main Execution
# ============================
check_dependencies
load_resolutions

# --- Handle standalone actions first ---

# Resolution list
if [[ "$ACTION" == "res-list" ]]; then
  action_res_list || exit 1
  exit 0
fi

# Resolution delete
if [[ "$ACTION" == "res-del" ]]; then
  action_res_del "$DEL_NAME" || exit 1
  exit 0
fi

# Layout actions
if [[ -n "$LAYOUT_ACTION" ]]; then
  case "$LAYOUT_ACTION" in
    list)  action_layout_list  || exit 1; exit 0 ;;
    save)  action_layout_save "$LAYOUT_NAME"  || exit 1; exit 0 ;;
    load)  action_layout_load "$LAYOUT_NAME"  || exit 1; exit 0 ;;
    del)   action_layout_del  "$LAYOUT_NAME"  || exit 1; exit 0 ;;
    ascii) action_layout_ascii "$LAYOUT_NAME"  || exit 1; exit 0 ;;
  esac
fi

# Display actions
if [[ "$ACTION" == "list" ]]; then
  action_list || exit 1
  exit 0
fi

if [[ "$ACTION" == "get-pos" ]]; then
  action_get_pos "$GETPOS_TARGET" || exit 1
  exit 0
fi

if [[ "$ACTION" == "off" ]]; then
  action_off || exit 1
  exit 0
fi

if [[ "$ACTION" == "off-all" ]]; then
  action_off_all || exit 1
  exit 0
fi

if [[ "$ACTION" == "purge" ]]; then
  action_purge || exit 1
  exit 0
fi

if [[ "$ACTION" == "purge-all" ]]; then
  action_purge_all || exit 1
  exit 0
fi
if [[ "$ACTION" == "align" ]]; then
  action_align || exit 1
  exit 0
fi

if [[ "$ACTION" == "tile" ]]; then
  action_tile || exit 1
  exit 0
fi

if [[ "$ACTION" == "pack" ]]; then
  action_pack || exit 1
  exit 0
fi


# --- Resolve base resolution ---
FINAL_W="" FINAL_H=""

if [[ -n "$RES_KEY" ]]; then
  read -r FINAL_W FINAL_H <<< "$(get_resolution "$RES_KEY")" || exit 1
  log_debug "Base from preset '$RES_KEY': ${FINAL_W}x${FINAL_H}"
elif [[ -n "$SIZE_W" ]]; then
  FINAL_W="$SIZE_W"
  FINAL_H="$SIZE_H"
  log_debug "Base from --size: ${FINAL_W}x${FINAL_H}"
fi

# --- Apply transforms ---
if [[ -n "$FINAL_W" && -n "$FINAL_H" ]]; then
  if [[ -n "$RATIO_STR" ]]; then
    _result=$(apply_ratio "$FINAL_W" "$FINAL_H" "$RATIO_STR") || exit 1
    IFS=' ' read -r FINAL_W FINAL_H <<< "$_result"
    log_debug "After ratio: ${FINAL_W}x${FINAL_H}"
  fi

  if [[ -n "$PERCENT_STR" ]]; then
    _result=$(apply_percentage "$FINAL_W" "$FINAL_H" "$PERCENT_STR") || exit 1
    IFS=' ' read -r FINAL_W FINAL_H <<< "$_result"
    log_debug "After percentage: ${FINAL_W}x${FINAL_H}"
  fi
fi

# --- Handle --save ---
if [[ -n "$SAVE_NAME" ]]; then
  # Resolve description: replace spaces with hyphens for config storage
  _desc="${DESC_STR:-Custom}"
  _desc="${_desc// /-}"

  if [[ -n "$TARGET_OUTPUT" && -z "$SIZE_W" && -z "$RES_KEY" && "$ACTION" == "output" ]]; then
    # Save resolution from existing output
    _current=$(get_output_mode "$TARGET_OUTPUT")
    if [[ -z "$_current" ]]; then
      log_error "Cannot get resolution from $TARGET_OUTPUT (not active?)"
      exit 1
    fi
    IFS=' ' read -r _sw _sh <<< "$_current"
    action_res_save "$SAVE_NAME" "$_sw" "$_sh" "$_desc" || exit 1
    exit 0
  elif [[ -n "$FINAL_W" && -n "$FINAL_H" ]]; then
    # Save computed resolution
    action_res_save "$SAVE_NAME" "$FINAL_W" "$FINAL_H" "$_desc" || exit 1
    exit 0
  elif [[ -z "$ACTION" ]]; then
    # No display action, no resolution → save layout
    action_layout_save "$SAVE_NAME" || exit 1
    exit 0
  else
    log_error "Ambiguous --save: specify context with -s/-o or -l"
    exit 1
  fi
fi

# --- Calculate position if --*-of was specified ---
if [[ -n "$POSITION_DIR" && -z "$POSITION_CMD" ]]; then
  if [[ -n "$FINAL_W" && -n "$FINAL_H" ]]; then
    read -r _pw _ph <<< "$(effective_dims_for_orientation "$FINAL_W" "$FINAL_H" "$ORIENTATION")"
    POSITION_CMD=$(calculate_position "$POSITION_DIR" "$POSITION_REF" "$POSITION_ALIGN" "$_pw" "$_ph") || exit 1
  else
    # Position needs dimensions — defer to action handler
    # For --change, dimensions will be resolved there
    :
  fi
fi

# --- Execute display action ---
case "$ACTION" in
  output)  action_output || exit 1 ;;
  change)  action_change || exit 1 ;;
  "")      action_auto || exit 1 ;;
  *)       log_error "Unhandled action: $ACTION"; exit 1 ;;
esac

exit 0

# TODO(@vlgoncalves): Reestruturar diretórios pensando em migração futura
#  Introduzir bin/ lib/ share/ tests/ e separar assets de completion/docs.
#  Evitar mudanças comportamentais; só mover/organizar.
#  labels: refactor, architecture

# TODO(@vlgoncalves): Modularizar o script em core + backend único X11
#  Extrair parser/log/geom para core e expor contrato mínimo (be_*).
#  Backend X11 vira implementação isolada (xrandr/cvt/newmode/ensure-fb).
#  labels: refactor, x11

# TODO(@vlgoncalves): Implementar backend Hyprland
#  Mapear contrato (be_*) para hyprctl (outputs, pos, rotate, scale, headless).
#  Manter feature parity mínima com X11 (align/tile/pack/pos/orientação).
#  labels: wayland, hyprland, enhancement

# TODO(@vlgoncalves): Criar backend Sway (porta futura)
#  Implementar be_* via swaymsg (outputs, pos, rotate, scale, headless/HEADLESS-*).
#  Documentar limitações vs X11 (modes custom/cvt não se aplicam).
#  labels: wayland, sway, enhancement

# TODO(@vlgoncalves): Criar backend COSMIC (porta futura)
#  Investigar interface estável (output management) e mapear para be_*.
#  Definir o mínimo suportado (sem prometer “VIRTUALn” se não existir).
#  labels: wayland, cosmic, research

# TODO(@vlgoncalves): Tornar testes independentes de xrandr via "backend state"
#  Adicionar ação `vscreen --dump-state` (estável/machine-readable) por backend.
#  Integration valida usando dump do backend, não parsing direto de xrandr.
#  labels: tests, architecture

# TODO(@vlgoncalves): Adicionar backend "mock" para CI/contrato
#  Implementar be_* fake em memória e testes de layout (align/tile/pack/overlap).
#  Mantém integration X11 como “manual/host”, sem travar sessão gráfica em CI.
#  labels: tests, ci

# TODO(@vlgoncalves): Seleção explícita de backend
#  Suportar `--backend x11|sway|hypr|cosmic` + autodetect via XDG_SESSION_TYPE.
#  labels: cli, architecture

# TODO(@vlgoncalves): Documentar “segurança” do integration test
#  Avisar que RandR churn pode travar sessão; sugerir rodar fora do desktop (TTY/Xephyr).
#  labels: docs, tests